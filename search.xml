<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[nginx-rtmp流媒体服务器搭建]]></title>
      <url>/2017/07/27/nginx-rtmp%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程:"></a>直播流程:</h2><p><img src="http://devfqh.com/images/live/live_p1.png" alt=""></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>1,先下载安装  nginx 和 nginx-rtmp 编译依赖工具<br>sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev</p>
<p>2,创建一个工作目录，并切换到工作目录<br>mkdir /usr/janino/nginx<br>cd /usr/janino/nginx</p>
<p>3,下载 nginx 和 nginx-rtmp源码（wget是一个从网络上自动下载文件的自由工具）<br>wget <a href="http://nginx.org/download/nginx-1.8.1.tar.gz" target="_blank" rel="external">http://nginx.org/download/nginx-1.8.1.tar.gz</a><br>wget <a href="https://github.com/arut/nginx-rtmp-module/archive/master.zip" target="_blank" rel="external">https://github.com/arut/nginx-rtmp-module/archive/master.zip</a></p>
<p>4,安装unzip工具，解压下载的安装包<br>sudo apt-get install unzip</p>
<p>5,解压 nginx 和 nginx-rtmp安装包<br>tar -zxvf nginx-1.7.5.tar.gz<br>-zxvf分别是四个参数<br>x : 从 tar 包中把文件提取出来<br>z : 表示 tar 包是被 gzip 压缩过的，所以解压时需要用 gunzip 解压<br>v : 显示详细信息<br>f xxx.tar.gz :  指定被处理的文件是 xxx.tar.gz</p>
<p>unzip master.zip</p>
<p>6,切换到 nginx-目录<br>cd nginx-1.7.5</p>
<p>7,添加 nginx-rtmp 模板编译到 nginx<br>./configure –with-http_ssl_module –add-module=../nginx-rtmp-module-master</p>
<p>8,编译安装<br>make<br>sudo make install</p>
<p>9,安装nginx init 脚本<br>sudo wget <a href="https://raw.github.com/JasonGiedymin/nginx-init-ubuntu/master/nginx" target="_blank" rel="external">https://raw.github.com/JasonGiedymin/nginx-init-ubuntu/master/nginx</a> -O /etc/init.d/nginx<br>sudo chmod +x /etc/init.d/nginx<br>sudo update-rc.d nginx defaults</p>
<p>10,启动和停止nginx 服务，生成配置文件<br>sudo service nginx start<br>sudo service nginx stop</p>
<p>11,安装 FFmpeg<br>make<br>make install</p>
<p>12,配置 nginx-rtmp 服务器<br>打开 /usr/local/nginx/conf/nginx.conf<br>在末尾添加如下 配置</p>
<p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">rtmp &#123;</div><div class="line">    server &#123;</div><div class="line">            listen 1935;</div><div class="line">            chunk_size 4096;</div><div class="line"></div><div class="line">            application live &#123;</div><div class="line">                    live on;</div><div class="line">                    record off;</div><div class="line">                    exec ffmpeg -i rtmp://localhost/live/$name -threads 1 -c:v libx264 -profile:v baseline -b:v 350K -s 640x360 -f flv -c:a aac -ac 1 -strict -2 -b:a 56k rtmp://localhost/live360p/$name;</div><div class="line">            &#125;</div><div class="line">            application live360p &#123;</div><div class="line">                    live on;</div><div class="line">                    record off;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>复制代码</p>
<p>13,保存上面配置文件，然后重新启动nginx服务<br>sudo service nginx restart</p>
<p>14,如果你使用了防火墙，请允许端口 tcp 1935</p>
<p>15,使用 客户端，使用 rtmp协议进行视频实时采集<br>Field 1: rtmp://your.vultr.ip/live/<br>Field 2: stream-key-your-set</p>
<p>服务器配置测试播放器：<br>将播放器复制到目录：/usr/local/nginx/html/，然后修改播放地址</p>
<p>用ffplay播放RTMP直播流：<br>ffplay “rtmp://pub1.guoshi.com/live/newcetv1 live=1”</p>
<p><strong>nginx:</strong><br><img src="http://devfqh.com/images/live/live_p2.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 直播 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -直播 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg编译]]></title>
      <url>/2017/07/26/ffmpeg%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<h2 id="编译-FFmpeg"><a href="#编译-FFmpeg" class="headerlink" title="编译 FFmpeg"></a>编译 FFmpeg</h2><p>1.阿里云主机 ubuntu 14.04 64位</p>
<p>2.安装XShell、Xftp</p>
<p>3.上传NDK、FFmpeg</p>
<p>4.安装VIM  sudo apt-get install vim-gtk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">命令模式</div><div class="line">退出，shift + :，输入q!强制退出</div><div class="line">保存退出,shift + z z</div><div class="line">进入编辑模式，i</div><div class="line">进入命令模式，Esc</div><div class="line">命令模式：x删除，dd删除行</div></pre></td></tr></table></figure>
<p>5.VIM配置<br>进入配置文件：vim /etc/vim/vimrc</p>
<p>set nu<br>set tabstop<br>set cursorline<br>set ruler</p>
<ol>
<li>NDK安装</li>
</ol>
<p>目录给权限：chmod 777 -R ndk<br>解压：./android-ndk-r10e-linux-x86_64.bin<br>环境变量配置：<br>命令vim ~/.bashrc<br>添加：<br>export NDKROOT=/usr/ndk/android-ndk-r10e<br>export PATH=$NDKROOT:$PATH<br>更新环境变量：<br>source ~/.bashrc</p>
<p>7.解压ffmpeg</p>
<p>unzip ffmpeg-2.6.9.zip</p>
<p>8.编译ffmpeg</p>
<p>1）编写shell脚本文件<br>2）给文件权限：chmod 777 android_build.sh<br>dos2unix<br>3）执行 ./android_build.sh</p>
]]></content>
      
        <categories>
            
            <category> 直播 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -直播 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux基础知识]]></title>
      <url>/2016/03/26/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>linux：</strong>开源的类unix操作系统，1991年由芬兰人Linus Torvalds编写，吉祥物为企鹅，由于其出色的性能、安全性等，广泛应用于服务器方面；</p>
<p><strong>常见的发行版本：</strong>redhat（收费）、fedora、ubuntu（图形界面出色）、centos都是linux的发行版本；</p>
<p><strong>GLI（Command Line User Interface）：</strong>命令行用户界面，效率高，适用于服务器<br><strong>GUI（Graphical User Interface）：</strong>图形用户接口，操作友好，例如windows、macos，缺点消耗资源，不适用于服务器；</p>
<p><strong>linux的安装方式：</strong>此处采用VMWare安装centos7来完成<br>    1，windows、linux双系统：不建议使用，较为繁琐，且容易出现引导、磁盘错误等…<br>    2，虚拟机安装（建议使用）：可通过VMware、Visual Box等虚拟机安装<br>    3，单独安装Linux：企业开发中最常用，作为服务器，通过windows远程控制</p>
<p><strong>root：</strong>超级用户，拥有所有权限；</p>
<p><strong>在VMware安装完centos后的网络设置： </strong>主要有三种方式<br>  1，NAT：即网络地址转换，名称通常为VMnet8，可使得与真实机的网卡在不同网段中，实现联网<br>  2，bridge：桥接，名称为VMnet0，可使得与真实机的网卡在同一网段中，实现联网<br>  3，host-only：仅主机模式，名称为VMnet1，不可与外界通信，只能与本机物理网卡通信</p>
<p><strong>NAT设置方式：</strong><br>    1，在windows中启动VMware的各种服务，并设置本地连接和VMnet8的ip地址自动获取（通常是默认的，不用管）<br>    2，VM中编辑 - 虚拟网络编辑器</p>
<p><img src="http://devfqh.com/images/Linux/part_p1.png" alt=""></p>
<p><img src="http://devfqh.com/images/Linux/part_p2.png" alt=""></p>
<p>  3，选中虚拟机 - 设置<br><img src="http://devfqh.com/images/Linux/part_p3.png" alt=""></p>
<p>   4，重启linux网卡，确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service NetworkManager stop</div><div class="line">service network restart</div><div class="line">service NetworkManager start</div><div class="line"></div><div class="line">host http://www.baidu.com     #进行确认,或者通过ifconfig</div></pre></td></tr></table></figure></p>
<p>命令可能会无效，直接进入centos7图形界面，在右上角勾选以下选项即可<br><img src="http://devfqh.com/images/Linux/part_p4.png" alt="">      </p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><p><strong>centos调出Terminal：</strong>application –&gt;  system tools –&gt; Terminal</p>
<p><strong>图形界面切换：</strong>在centos中可通过ctrl + alt + f2进行切换</p>
<pre><code>startx  #切换至图形界面
</code></pre><p><strong>用户登录：</strong> su 用户名，再输入密码即可完成登录，在命令行下以$为普通用户，以#开头则代表root<br>    su  root</p>
<p><strong>关机、重启命令：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">shutdown -h now         #立即关机</div><div class="line">shutdown -r now         #立即重启</div><div class="line">shutdown -t 10          #10秒后关机</div><div class="line">shutdown -c             #取消正在执行的shutdown命令</div><div class="line">reboot                  #重启计算机</div><div class="line">logout                  #注销</div></pre></td></tr></table></figure></p>
<p><strong>清屏：</strong><br>    clear</p>
<p><strong>程序退出：</strong><br>    exit 0  #程序正常退出，非0为不正常</p>
<p><strong>ctrl  + c：</strong> <code>结束操作</code></p>
<p><strong>寻求帮助：</strong><br>    man find  #查看find命令的文档</p>
<p><strong>uname -a：</strong> <code>查看系统版本</code></p>
<h2 id="启动级别"><a href="#启动级别" class="headerlink" title="启动级别"></a>启动级别</h2><p><strong>linux启动级别：</strong>总共有7个运行级别，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0：系统停机状态，无法运行</div><div class="line">1：单用户工作状态，用户系统维护，禁止远程登录</div><div class="line">2：多用户状态，无NFS，看不懂，没用</div><div class="line">3：完全的多用户状态，登陆后进入命令行界面（常用）</div><div class="line">4：系统未使用，保留的</div><div class="line">5：图像界面模式（常用，默认的）</div><div class="line">6：系统正常关闭并无限重启</div></pre></td></tr></table></figure></p>
<p><strong>查看运行级别：</strong><br>    runlevel</p>
<p><strong>linux改变运行级别：</strong><br><strong>临时设置：</strong><br>        init 5  #临时切换启动级别,重启后还原不会永久生效    </p>
<p><strong>永久设置：</strong><br>    1，登录后通过通过vi编辑器打开/etc/inittab文件，vi编辑器具体使用后续会讲<br>         vi /etc/inittab<br>    2，找到id:5:initdefault，将其改为3命令行即可</p>
<p><img src="http://devfqh.com/images/Linux/part_p5.png" alt=""></p>
<pre><code>3，之后通过reboot重新启动，即可进入命令行界面，可通过startx切换到图形界面
</code></pre><p><strong>不小心设置启动级别为6后，不断重启的解决方案：</strong><br>1，在linux系统读秒阶段，按下e<br>2，进入下一个界面，需再按一次e<br>3，选择<img src="http://devfqh.com/images/Linux/part_p6.png" alt="">再次按下e<br>4，在此处输入1 <img src="http://devfqh.com/images/Linux/part_p7.png" alt=""></p>
<p>5，回车后返回到之前的界面，选择 <img src="http://devfqh.com/images/Linux/part_p8.png" alt="">，按下B，系统即可以level1运行</p>
<p>6，之后在设置还原启动级别即可</p>
<p><strong>centos7设置启动级别（与传统linux不同）：</strong>centos7升级后，不使用/etc/inittab，通过target常量定义的方式来设置，与之前不同，都定义在了/lib/systemd/system下</p>
<p><strong>1，查看启动级别常量定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ls -ltr /lib/systemd/system/runlevel*</div><div class="line"></div><div class="line">lrwxrwxrwx. 1 root root 13 7月  30 14:22 /lib/systemd/system/runlevel1.target -&gt; rescue.target</div><div class="line">lrwxrwxrwx. 1 root root 15 7月  30 14:22 /lib/systemd/system/runlevel0.target -&gt; poweroff.target</div><div class="line">lrwxrwxrwx. 1 root root 17 7月  30 14:22 /lib/systemd/system/runlevel2.target -&gt; multi-user.target</div><div class="line">lrwxrwxrwx. 1 root root 17 7月  30 14:22 /lib/systemd/system/runlevel3.target -&gt; multi-user.target</div><div class="line">lrwxrwxrwx. 1 root root 17 7月  30 14:22 /lib/systemd/system/runlevel4.target -&gt; multi-user.target</div><div class="line">lrwxrwxrwx. 1 root root 16 7月  30 14:22 /lib/systemd/system/runlevel5.target -&gt; graphical.target</div><div class="line">lrwxrwxrwx. 1 root root 13 7月  30 14:22 /lib/systemd/system/runlevel6.target -&gt; reboot.target</div></pre></td></tr></table></figure></p>
<p><strong>2，切换启动级别：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ln -sf /lib/systemd/system/runlevel3.target /etc/systemd/system/default.target      #两者皆可，只是个别名而已</div><div class="line"></div><div class="line">ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target</div></pre></td></tr></table></figure></p>
<p><strong>3，centos7设置默认启动级别：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl set-default multi-user.target</div></pre></td></tr></table></figure></p>
<p><strong>centos7设置启动级别6后，解决方案：</strong>新的版本使用了grub2，因此设置方法略有不同<br>    1，在linux系统读秒阶段，按下e</p>
<p><img src="http://devfqh.com/images/Linux/part_p9.png" alt=""></p>
<pre><code>2，找到linux16这一行，将ro改为rw，并且在rhgb quiet后面加上3，即rhgb quiet 3
</code></pre><p><img src="http://devfqh.com/images/Linux/part_p9.png" alt=""></p>
<pre><code>3，之后按ctrl + 重启，然后再重新将启动级别设置还原即可
</code></pre><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>说明：</strong>与window不同，linux的文件系统是以层级为目录的，根为“/”，所有以/开头的都是绝对路径；</p>
<p><img src="http://devfqh.com/images/\ComputerBase/CBase_p66.png" alt=""></p>
<p><strong>目录描述：加粗斜体为常用</strong></p>
<p><strong><em>/：</em></strong> <code>文件系统的根，只有root用户才具有此目录下的写权限</code><br><strong><em>/bin：</em></strong> <code>存放常用的用户命令，例如vi、mkdir、ls、rm、ping、ps...</code><br><strong><em>/sbin：</em></strong> <code>存放常用系统命令，只有root才可用，通常为系统管理员维护使用，例如reboot、fdisk、ifconfig、swapo等命令...</code><br><strong><em>/etc：</em></strong> <code>存放配置文件，例如常见的环境变量、各种系统配置...</code><br><strong><em>/home：</em></strong> <code>用户的目录，用于存放每个用户的数据，例如/home/zjt  /home/james</code><br><strong><em>/usr：</em></strong> <code>用户程序，默认安装目录，例如常见的eclipse、mysql都可安装到此，类似于windows的program files</code><br><strong><em>/proc：</em></strong> <code>存放系统的进程信息</code><br><strong><em>/mnt：</em></strong> <code>磁盘挂载目录，可用于移动设备的临时目录，例如u盘等</code><br><strong><em>/dev：</em></strong> <code>设备文件，在linux上设备也被当做一个文件来管理</code><br><strong><em>/var：</em></strong> <code>变量文件</code><br><strong><em>/tmp：</em></strong> <code>临时文件</code><br><strong><em>/boot：</em></strong> <code>存放引导程序</code><br><strong><em>/lib：</em></strong> <code>系统库</code><br><strong><em>/opt：</em></strong> <code>一些附加选项</code><br><strong><em>/media：</em></strong> <code>媒体设备</code><br><strong><em>/srv：</em></strong> <code>服务设备，包含了特点服务的信息</code></p>
<h2 id="目录、文件操作"><a href="#目录、文件操作" class="headerlink" title="目录、文件操作"></a>目录、文件操作</h2><p><strong>查看当前目录：</strong><br>    pwd</p>
<p><strong>切换目录：</strong><br>    cd /etc</p>
<p><strong>创建目录：</strong><br><code>mkdir dir1</code>                   #创建目录</p>
<p><code>mkdir -p dir1/dir2/dir3</code>     #递归创建目录</p>
<p><code>mkdir -m 757 dir1</code>            #创建目录，并指定权限（后续会介绍）</p>
<p><strong>删除目录或文件：</strong><br><code>rmdir dir1</code>      #删除目录<br><code>rm -rf dir1</code>     #递归删除目录，且不可恢复</p>
<p><strong>重命名：</strong><br><code>mv dir1 dir2</code>      #将dir1重命名为dir2</p>
<p><strong>剪切（即移动）：</strong><br><code>mv a.txt dir1</code>      #将a.txt移动到dir1中</p>
<p><code>mv dir1 dir2</code>       #移动文件夹，将dir1移动到dir2中</p>
<p><code>mv /dir1/* dir2</code>    #统配符方式，将dir1下的所有文件及目录移动到dir2中</p>
<p><strong>拷贝：</strong><br><code>cd -rf dir1 dir2</code>    #递归拷贝dir1中的所有文件到dir2<br><strong>命令参数：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-f：强行复制文件或目录，无论目的文件是否已存在</div><div class="line">-p：保留源文件或目录的属性，例如所有者、所在组、权限、时间等</div><div class="line">-r：递归处理，将子目录及其文件一起复制</div><div class="line">.........</div></pre></td></tr></table></figure></p>
<p><strong>touch：</strong>  #创建空文件，可指定修改时间为未来时间<br><strong>touch b.txt </strong>       #创建一个空文件b.txt</p>
<p><strong>touch -m b.txt</strong>     #更新修改时间</p>
<p><strong>touch -t 201211142234 b.txt </strong>    #指定修改时间</p>
<p><strong>dir、vdir：</strong>查看目录，功能较少，建议使用ls</p>
<p><strong>ls：</strong> <code>最常用的命令，用于查看文件、目录信息，参数众多</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls        #查看文件、目录</div><div class="line"></div><div class="line">ls -l     #查看文件目录详情,包含文件权限、所有者、大小等信</div><div class="line"></div><div class="line">ls -al | more     #如果查看信息过多，可通过管道命令，将结果转到more命令分页</div></pre></td></tr></table></figure></p>
<p><strong>命令参数：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-a：列出目录下所有文件，包含以.开头的隐藏文件</div><div class="line">-l：查看详细信息</div><div class="line">-c：按修改时间排序</div><div class="line">-s：按大小排序</div><div class="line">.........</div></pre></td></tr></table></figure></p>
<p><strong>通配符使用：</strong> <code>*、？、[]，很多命令都支持通配符，例如find、ls等等...</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls *.c            #查看以c结尾</div><div class="line"> </div><div class="line">ls demo?          #查看以demo开头，并后面只有1个字符</div><div class="line"> </div><div class="line">ls demo[1-9]      #查看demo0到demo9</div></pre></td></tr></table></figure></p>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p><strong>grep：</strong>在文本中查询内容，格式为grep [-参数] ‘搜索内容’ file</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言基础]]></title>
      <url>/2015/11/26/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>入门第一语言HelloWorld？哈哈。原因是当年C语言的作者，Dennis Ritchie(丹尼斯·里奇)在他的名著《C程序设计语言（The C Programming Langupeach）》中第一次引入，传为后世经典，其它语言亦争相效仿，以示致敬。<br><img src="http://devfqh.com/images/C/chapter_one1.png" alt=""></p>
<p><strong>优点：</strong>高效率、跨平台、灵活、可操作内存、访问硬件、强大函数库等；且由于c的出现，此后诞生的程序语言大致都参照与c语言的风格。<br><strong>缺点：</strong>指针的风险，面向过程性等。</p>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><p><strong><em>C版</em></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // 程序库函数，包含printf所在的头文件</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>); <span class="comment">// 调用库函数，向屏幕打印Hello World！</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// main函数的返回值</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>C++版</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 程序库函数，包含cout所在的头文件</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;	<span class="comment">// 用到的命名空间 </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"HelloWorld!"</span>&lt;&lt; end1;	<span class="comment">// 通过类对象cout，向屏幕输出HelloWorld!</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// main 函数的返回值</span></div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>上面的两个示例中，//后面的语句，表示程序的注释，用来注解的作用，不参于编译，以便后期的维护和管理</p>
<h2 id="从源程序到可执行程序"><a href="#从源程序到可执行程序" class="headerlink" title="从源程序到可执行程序"></a>从源程序到可执行程序</h2><p>源程序就是一个.txt 的普通文本文件，是经历了哪些过程，变为可执行性文件的呢?大体上分为四个步骤 ：<strong><em>预处理-&gt;编译-&gt;汇编-&gt;链接 </em></strong> 四个过程。<br><img src="http://devfqh.com/images/C/chapter_one2.png" alt=""></p>
<h2 id="C编程中文件后缀介绍："><a href="#C编程中文件后缀介绍：" class="headerlink" title="C编程中文件后缀介绍："></a>C编程中文件后缀介绍：</h2><pre><code>.c：源代码
.h：头文件，本质上就是.c源程序，用于为其它c程序提供服务. 避免重复代码编写.
.i：经过预处理的c源码
.s .asm：汇编代码
.o .obj：目标文件，存放了机器代码.
</code></pre><h2 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h2><p><strong>编译器：</strong>将高级语言解释成计算机所识别的机器语言指令，最常用为gcc，windows可下载mingw-w64，并将mingw64\bin注册到环境变量中；</p>
<p><strong>简单编译（-o）：最常用，可直接生成可执行文件，内部包含了预处理、编译、汇编、链接四个阶段</strong>        </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc demo.c -o demo</div></pre></td></tr></table></figure>
<p>1，预处理：进行预处理，并生成.i文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E  demo.c  或者  gcc -E  demo.c  -o  demo.i</div></pre></td></tr></table></figure></p>
<p>2，编译：即将预处理后的.i文件，翻译成汇编代码，为.s文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S demo.i -o demo.s</div></pre></td></tr></table></figure></p>
<p>3，汇编：将汇编代码翻译成最终的目标文件，即机器指令（二进制），通常为.o、.obj<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c demo.s -o demo.o</div></pre></td></tr></table></figure></p>
<p>4，链接：将程序的目标文件和所有关联的文件，相关联，并最终生成可执行文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc demo.o -o demo</div></pre></td></tr></table></figure></p>
<p><strong>多个程序文件的编译：开发时通常会直接生成可执行文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc demo1.c demo2.c -o demo</div></pre></td></tr></table></figure></p>
<p><strong>检查错误：-pedantic选项可以查看不符合ANSI/ISO C标准的代码-Werror可以查看错误信息 </strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcc  -pedantic   demo.c  -o  demo</div><div class="line">gcc  -Werror  demo.c  -o demo</div></pre></td></tr></table></figure></p>
<p><strong>库连接：有时候可能会使用除了标准c之外的函数库，那么就需要进行库连接，通常是.so、.lib、.dll    </strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c -I /usr/dev/mysql/include demo.c -o demo.o</div></pre></td></tr></table></figure></p>
<p><strong>强制链接时使用静态链接库：默认情况下，gcc在链接时优先使用动态连接库（通常以.so、.dll结尾），只有动态链接库不存在时，才会考虑静态链接库，可通过-static强制进行</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –<span class="keyword">static</span> –lmysqlclient demo.o –o demo</div></pre></td></tr></table></figure>
<p><strong>unix/linux静态库链接时搜索路径顺序：</strong></p>
<ol>
<li>ld会去找GCC命令中的参数-L</li>
<li>再找gcc的环境变量LIBRARY_PATH</li>
<li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li>
</ol>
<p><strong>动态链接时、执行时搜索路径顺序:</strong></p>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib</li>
<li>默认的动态库搜索路径/usr/lib</li>
</ol>
<p><strong>有关环境变量：</strong><br><strong><em>LIBRARY_PATH</em></strong>：指定程序静态链接库文件搜索路径<br><strong><em>LD_LIBRARY_PATH</em></strong>：指定程序动态链接库文件搜索路径</p>
<h2 id="C语言中的关键字"><a href="#C语言中的关键字" class="headerlink" title="C语言中的关键字"></a>C语言中的关键字</h2><p>关键字，也叫保留字。已经被C语言赋予了特殊的意义，所以我们既要研究其特殊的意义，也要跟其不发生冲突。<br><img src="http://devfqh.com/images/C/chapter_one11.png" alt=""></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><strong><em>QT/VS/g++</em></strong><br><img src="http://devfqh.com/images/C/chapter_one3.png" alt=""></p>
<p><strong><em>下载地址</em></strong>       </p>
<ol>
<li>VisualStudio官方：<a href="https：//www.visualstudio.com/" title="vs">https：//www.visualstudio.com/</a><br>2.Qt 官方：<a href="https://www.qt.io/download/" title="qt" target="_blank" rel="external">https://www.qt.io/download/</a></li>
</ol>
<h2 id="手动编译"><a href="#手动编译" class="headerlink" title="手动编译"></a>手动编译</h2><p>unix/linux 环境下，通常没有界面，所以少有集成开发环境。所有的开发均是在命令行模试下，开发的。以vim 为编辑器，以gcc为编译器为例，演示。<br><img src="http://devfqh.com/images/C/chapter_one4.png" alt=""><br><img src="http://devfqh.com/images/C/chapter_one5.png" alt="">        </p>
<p>① 预处理：预处理相当于根据预处理命令组装成新的C 程序，不过常以i 为扩展名。<br>② 编 译：将得到的i 文件翻译成汇编代码 .s 文件。<br>③ 汇 编：将汇编文件翻译成机器指令，并打包成可重定位目标程序的O 文件。该文件是二进制文件，字节编码是机器指令。<br>④ 链 接：将引用的其他O文件并入到我们程序所在的o文件中，处理得到最终的可执行文件。 </p>
<h1 id="C语言与自然语言"><a href="#C语言与自然语言" class="headerlink" title="C语言与自然语言"></a>C语言与自然语言</h1><p>##语法规则<br>    任何一门计算机语言，其实就是在模仿自然语言（数学语言），模仿得越像，这门语言更容易，也即便容易上手。<br>    但是计算机语言是一种定义在机器上的语言，当然完全模式是不太可能的，于是就有了规则，规则即语法，只有深爱</p>
<h2 id="程序与流程"><a href="#程序与流程" class="headerlink" title="程序与流程"></a>程序与流程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序一词来自生活，通常指完成某些事务的一种既定方式和过程在日常生活中，可以将程序看成对一系列动作的执行过程的描述 。 </p>
<p><strong>生活中 ： </strong><br><img src="http://devfqh.com/images/C/chapter_one6.png" alt=""><br>程序 ：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合 </p>
<p><strong>计算机中 ： </strong><br><img src="http://devfqh.com/images/C/chapter_one7.png" alt="">    </p>
<h2 id="流程和流程图"><a href="#流程和流程图" class="headerlink" title="流程和流程图"></a>流程和流程图</h2><h3 id="流程即算法"><a href="#流程即算法" class="headerlink" title="流程即算法"></a>流程即算法</h3><p>算法：解决问题的具体方法和步骤。算法是有优劣之分，在计算机中常用时间复杂度和空间复杂度来衡量的，在后序课程讲算法的时候会有详细的讲解。<br>如何来描述算法呢？比如，我现在要计算一个长方形的面积。我就要用自然语言去描述他。<br>       算法如下：<br>       ① 接收用户输入的长方形长度和宽度两个值；<br>       ② 判断长度和宽度的值是否大于零；<br>       ③ 如果大于零，将长度和宽度两个值相乘得到面积，否则显示输入错误；<br>       ④ 显示面积 </p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>为了更易于表达清楚，常采用流程图的方式：<br><img src="http://devfqh.com/images/C/chapter_one8.png" alt=""></p>
<p>流程图是算法的一种图形化表示方式。流程图直观、清晰，更有利于人们设计与理解算法。<br>它使用一组预定义的符号来说明如何执行特定任务。<br><img src="http://devfqh.com/images/C/chapter_one9.png" alt=""></p>
<h1 id="常-变量与数据类型"><a href="#常-变量与数据类型" class="headerlink" title="常/变量与数据类型"></a>常/变量与数据类型</h1><p><img src="http://devfqh.com/images/C/chapter_one10.png" alt=""><br>当用计算器语言来描述世界的时候，比如一个人的性别，身高，体重，收入，就需要变量来存储，变量之间不仅仅需要名字来识别，还需要类型来进行限定。        </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code>类型        变量名;
</code></pre><h3 id="变量的命名规则："><a href="#变量的命名规则：" class="headerlink" title="变量的命名规则："></a>变量的命名规则：</h3><ul>
<li>变量名可以由字母、数字和 _ （下划线）组合而成。 </li>
<li>变量名不能包含除 _ 以外的任何特殊字符 ，如 ：%、# 、逗号、空格等。 </li>
<li>变量名必须以字母或 _ （下划线）开头。 </li>
<li>变量名不能包含空白字符（换行符、空格和制表符称为空白字符）。 </li>
<li>C 语言中的某些词（例如 int 和 float 等）称为保留字，具有特殊意义，不能用作变量名。 </li>
<li>C 语言区分大小写，因此变量 price 与变量 PRICE 是两个不同的变量。 </li>
</ul>
<p>如下名字是合法的：<br><strong>a_b、a1b、_Ab</strong><br>如下名字则不合法的：<br><strong>a@b、2ab、a-b</strong> </p>
<h3 id="交换两个变量的内容"><a href="#交换两个变量的内容" class="headerlink" title="交换两个变量的内容"></a>交换两个变量的内容</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">4</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">9</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d b = %d \n"</span>,a,b);</div><div class="line">	</div><div class="line">	a = b;</div><div class="line">	b = a;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d b = %d \n"</span>,a,b);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> temp;</div><div class="line">	temp = a;</div><div class="line">	a = b;</div><div class="line">	b = temp;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d b = %d \n"</span>,a,b);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h3><p>骆驼式命名法就是当变量名或函式名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstProject、helloWorld，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。<br><img src="http://devfqh.com/images/C/chapter_one12.png" alt=""><br>骆驼式命名法的命名规则可视为一种惯例，并无绝对与强制，为的是增加识别和可读性。</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="物理基础"><a href="#物理基础" class="headerlink" title="物理基础"></a>物理基础</h3><p>对于32机而言，内存模型线性的，这是硬件基础。左边表示十六进制的访问地址，右边分别表示寻址的最小单位Byte和Byte的最小单位bit，1Byte = 8bit。<br><img src="http://devfqh.com/images/C/chapter_one13.png" alt=""><br><img src="http://devfqh.com/images/C/chapter_one14.png" alt="">        </p>
<h3 id="CPU读写内存"><a href="#CPU读写内存" class="headerlink" title="CPU读写内存"></a>CPU读写内存</h3><p>CPU 在运作时，读取内存数据，首先要指定存储单元的地址。就是要确实读写的那段数据。即要明确三件事。        </p>
<ul>
<li>存储单元的地址（地址信息）</li>
<li>器件的选择，读 or 写（控制信息）</li>
<li>读写的数据（数据信息）</li>
</ul>
<h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>其中CUP通过地址总线要寻址，指定存储单元。可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。有10根地址总线，就能传送10 位二进制数据，也就是2 的10 次方。最小位0，最大为1023。也就是2n = 最大传输 n= 多少地址总线。<br> <em>CPU地址总线的宽带决定了CPU 的寻址能力。</em> </p>
<h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>CPU与内存或其他器件时行数据传达是通过数据总线来进行的。8根数据总线一次可以传送8位二进制数据。16根数据总线一次可以传2个字节。           <em>数据总线的宽度决定了CPU和外界的数据传输速度。</em></p>
<h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>CPU对外部部件的控制时通过控制总线来进行的。控制总线是个总称，控制总线是有不同的控制线来集合的。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。<br><em>控制总线的宽带决定了CPU对外部部件的控制能力。</em></p>
<h3 id="读写流程："><a href="#读写流程：" class="headerlink" title="读写流程："></a>读写流程：</h3><h4 id="读取流程（从3单元读取数据）"><a href="#读取流程（从3单元读取数据）" class="headerlink" title="读取流程（从3单元读取数据）"></a>读取流程（从3单元读取数据）</h4><p><img src="http://devfqh.com/images/C/chapter_one15.png" alt=""><br>① CPU通过地址线将地址信息3发出。<br>② CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>③ 存储器将3号单元中的数据8通过数据线送入CPU。 </p>
<h4 id="写入流程（将26写入单元3）"><a href="#写入流程（将26写入单元3）" class="headerlink" title="写入流程（将26写入单元3）"></a>写入流程（将26写入单元3）</h4><p><img src="http://devfqh.com/images/C/chapter_one16.png" alt=""><br>① CPU通过地址线将地址信息3 发出。<br>② CPU通过地址线发出内存写命令，选中存储器芯片，并通知它，要其写入数据。<br>③ CPU通过数据线将数据26送入内存3单元中。 </p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">8</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">9</span>;</div><div class="line">	<span class="keyword">int</span> c = a + b;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>规定在内存中开辟空间存储数据的类型. 对存储、获取、解释都有作用</strong></p>
<ul>
<li>基本类型： C语言中的基本数据类型、包括所有数值类型、枚举.</li>
<li>构造类型： 就是使用基本类型的数据、进行添加、设计构造出新的数据类型来解决问题. 如struct</li>
<li>指针类型： C语言的精华就是指针、其值代表某个内存地址；</li>
<li>空类型： 关键字是void、主要用于对函数返回的限定、对函数参数的限定.<br><img src="http://devfqh.com/images/C/chapter_one17.png" alt="">        </li>
</ul>
<p><strong>unsigned</strong>：代表无符号，只可代表正数，省略空间. 可表示更大的正数.<br><strong>signed</strong>：带符号，可表示正负数，默认情况下所有基本数据类型都带符号；</p>
<p><strong>说明：</strong></p>
<ol>
<li>在c99标准后，可直接使用变量，而无需先声明所有变量、再使用；</li>
<li>int num = 018;   八进制  int num = 0x18;  十六进制</li>
<li>可对数值常量指定存储类型，例如422L：代表long      232.21f：代表float</li>
</ol>
<p><strong>e计数法：</strong>3.15e7 代表3.15乘以10的7次方.  如为e-7则代表除以10的7次方. 7称为指数.<br><strong>char：</strong>用于存储单个字符，但实际存储的是int字符编码，长度为8位；将’FILE’赋给char，只能存储最后8位，最终变量的值为’E’;<br><strong>字符和字符串：</strong>使用单引号’’代表一个字符，而使用双引号” ”代表一个字符串，c语言存储字符串时会自动加上\0作为结束标志；c语言中使用字符串是通过char指针和char数组；    </p>
<p><strong>typedef：</strong>可为任意数据类型起别名，例如：typedef int myint;  通常用于block、struct等。<br><em>自动数据类型转换：</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num1 = <span class="number">20</span>;           <span class="comment">//需要级别兼容性、如：int 转 double</span></div><div class="line"><span class="keyword">double</span>  num2 = num1;</div></pre></td></tr></table></figure></p>
<p><em>强制数据类型转换：</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> f = <span class="number">20.3f</span>;     <span class="comment">//目标类型必须大于被转换类型，否则可能数据丢失；</span></div><div class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) f;</div><div class="line">```![](http:<span class="comment">//devfqh.com/images/C/chapter_one17.png)</span></div><div class="line"></div><div class="line">**自动类型提升机制：**<span class="keyword">float</span>在传参时被提升为<span class="keyword">double</span>. <span class="keyword">char</span>和<span class="keyword">short</span>会被提升为<span class="keyword">int</span>类型；</div><div class="line"></div><div class="line">### 基本类型之数值类型</div><div class="line">#### 输出类型大小</div><div class="line">```c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"int size = %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"long size = %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"double size = %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</div><div class="line">	<span class="comment">// 其他依此类推即可。</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基本类型之字符类型"><a href="#基本类型之字符类型" class="headerlink" title="基本类型之字符类型"></a>基本类型之字符类型</h3><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p><img src="http://devfqh.com/images/C/chapter_one18.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> val = <span class="string">'j'</span>;</div><div class="line">	<span class="keyword">for</span>(;val&lt;=<span class="string">'z'</span>;val++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%c\t"</span>,val);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符：自身已有一个字符的意义，可以给他另外一个别的意义。转义字符常起到控制的作用。<br><img src="http://devfqh.com/images/C/chapter_one19.png" alt=""></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><p>常量是程序中不可改变的量，常以字面量，或者宏的方式出现。主要用于赋值或是参与计算,并且常量也是用类型的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1425926 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRICE 200 </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> a = <span class="number">50</span>; </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="常量类型"><a href="#常量类型" class="headerlink" title="常量类型"></a>常量类型</h3><h4 id="整形常量"><a href="#整形常量" class="headerlink" title="整形常量"></a>整形常量</h4><p>整型常量有三种表形式 </p>
<p><strong>1.十进制表示：</strong><br>除表示整数0 外，不以0开头（以0开头的数字串会被解释成八进制数）。负数在前面加负号 ‘-’，后缀 ‘l’或 ‘L’表示长整型， ‘u’或 ‘U’表示无符号数。<br> 例：345     31684   0   -23456  459L  356l  56789u   567LU </p>
<p><strong>2.八进制表示： </strong><br> 以数字0开头的一个连续数字序列，序列中只能有0-7 这八个数字。<br> 例：045  -076    06745l   0177777u </p>
<p><strong>3.十六进制表示： </strong><br> 以0X 或0x 开头的连续数字和字母序列，序列中只能有0-9、A-F和 a-f 这些数字和字母，字母a、b、c、d、e、f 分别对应数字10、11、12、13、14、15，大小写均可。<br> 例：0x10  0X255  0xd4ef  0X6a7bL </p>
<h4 id="实型常量"><a href="#实型常量" class="headerlink" title="实型常量"></a>实型常量</h4><p>实型常量有两种表示形式：</p>
<p><strong>1、小数形式：</strong><br>       由数字和小数点组成，必须有小数点。<br>       例：4.23、0.15、.56、78.、0.0 </p>
<p><strong>2、指数形式：</strong><br>       以幂的形式表示，以字母e 或E后跟一个以10 为底的幂数。<br>        （1）字母e或E之前后必须要有数字。<br>        （2）字母e 或E后面的指数必须为整数，字母e或E 的前后及数字之间不得有空格。默认是double型，后缀为“f”或“F”即表示该数为float型，后缀“l”或“L” </p>
<h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>字符常量的表现形式比较简单。以单引号引起来的一个字符。<br>   例 ：’a’  ‘b’ ‘c’ </p>
<h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>字符串常量的表现形式比较简单。以单引号引起来的一串字符。<br>   例 ：”a”  “abcdefg” </p>
<h2 id="格式输入与输出"><a href="#格式输入与输出" class="headerlink" title="格式输入与输出"></a>格式输入与输出</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><h4 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h4><p>printf 函数称为格式输出函数，其关键字最末一个字母f 即为“格式”(format)之意。其功能是按用户指定的格式，把指定的数据显示到显示器屏幕上。<br>printf 函数调用的一般形式： <strong>printf( “格式控制字符串“,输出表列); </strong></p>
<p>其中格式控制字符串用于指定输出格式。格式控制串可由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串，在%后面跟有各种格式字符，以说明输出数据的类型、形式、长度、小数位数等。如： </p>
<ul>
<li>“%d“表示按十进制整型输出。 </li>
<li>“%f“表示按单精度浮点数输出。 </li>
<li>“%c“表示按字符型输出等。 </li>
</ul>
<p>非格式字符串原样输出，在显示中起提示作用。输出表列中给出了各个输出项，要求格式字符串和各输出项在数量和类型上应该一一对应。 </p>
<h4 id="格式串"><a href="#格式串" class="headerlink" title="格式串"></a>格式串</h4><p><code>形式: &quot;%[标志][输出最小宽度][.精度][长度]类型&quot;</code></p>
<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><h4 id="基本使用介绍"><a href="#基本使用介绍" class="headerlink" title="基本使用介绍"></a>基本使用介绍</h4><p>scanf函数的一般形式为: <strong>scanf(“格式控制字符串”,地址表列);</strong></p>
<p>其中，格式控制字符串的作用与printf 函数相同，<strong>地址表列中给出各变量的地址。</strong> 地址是由地址运算符“&amp;”后跟变量名组成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如： &amp;a、&amp;b 分别表示变量a 和变量b 的地址。</div></pre></td></tr></table></figure></p>
<p><code>这个地址就是编译系统在内存中给a、b变量分配的地址。在C语言中，使用了地址这个概念，这是与其它语言不同的。应该把变量的值和变量的地址这两个不同的概念区别开来。变量的地址是C编译系统分配的，用户不必关心具体的地址是多少。</code></p>
<h4 id="格式串-1"><a href="#格式串-1" class="headerlink" title="格式串"></a>格式串</h4><p>格式字符串的一般形式为: <strong>%[*][输入数据宽度][长度]类型</strong></p>
<p>其中有方括号[]的项为任选项.</p>
<h3 id="putchar-amp-amp-getchar"><a href="#putchar-amp-amp-getchar" class="headerlink" title="putchar &amp;&amp; getchar"></a>putchar &amp;&amp; getchar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int putchat (int character); 向屏幕输出一个字符</div><div class="line">int getchar (void);	从键盘获得一个字符</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> ch;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pls input a char:"</span>);</div><div class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);</div><div class="line">	ch = getchar();</div><div class="line">	<span class="built_in">putchar</span>(ch);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><strong>赋值运算符：</strong>  <code>=  +=  -=  *=  /=  %=；</code>   //可多重赋值，从右往左开始</p>
<p><strong>算术运算符：</strong> <code>+ - * / % ++  —</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">num++：先运算再自增，例如：num++ * 2 == num + 1 * 2</div><div class="line">++num：先自增后运算，例如：++num * 2 == (num + 1) * 2</div></pre></td></tr></table></figure></p>
<p><strong>关系运算符：</strong> <code>&gt;   &gt;=       &lt; &lt;=       ==  !=</code></p>
<p><strong>逻辑运算符：</strong>  <code>&amp;&amp;：与     ||：或      !：非</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">双个具有断电功能，即一边不符合条件，则另外一边不会再判断；</div></pre></td></tr></table></figure>
<p><strong>在c语言中、可用逗号运算符将多个表达式分隔、例如：</strong><br><code>int  value =  2+5,1+2,5+7;      //赋值运算符的优先级比逗号高，2+5赋给了value</code></p>
<p><strong>位运算：</strong>直接对二进制进行操作的运算符，高效率，在c程序中1：true   0：false</p>
<p><strong>说明：</strong>在计算机中，通常0代表false，1代表true;</p>
<p><strong>逻辑运算符主要有：</strong> <code>&amp;（位与）、|（位或）、~（非）、^（异或）</code></p>
<p><strong>&amp; ：</strong> <code>位与（AND），两个都是1，返回1，其它返回0；</code></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p10.png" alt=""></p>
<p><strong>|：</strong> <code>位或（OR），有一个为1则返回1，2个都为0返回0</code></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p11.png" alt="">     </p>
<p><strong>^：</strong> <code>异或，即两个比较的位数不同为1，相同为0；（0和1返回1；0和0,1和1返回0）</code></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p13.png" alt="">           </p>
<p><strong>~：</strong> <code>取反，单目运算符，0变成1，1变成0；</code></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p12.png" alt="">        </p>
<p><strong>位移运算：</strong> <code>将数值的二进制形式，左移或右移n位. 不足补0.</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;：左移变大       高位舍弃，低位补0;</div><div class="line">&gt;&gt;：右移变小       低位舍弃，高位补0；</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p14.png" alt="">    </p>
<p><strong>快捷算法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3  &lt;&lt;  2  =   3 * 2②</div><div class="line">6  &gt;&gt;  2  =   6 / 2②</div></pre></td></tr></table></figure></p>
<p><strong>定点数表示法：</strong>计算机中有原码、反码、补码来表示；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原码：使用数值的最高位来代表符号位，0代表正数；1代表负数；</div><div class="line">反码：正数的反码与原码相同；负数的反码等于除了最高位符号外，其它位取反；</div><div class="line">补码：正数的补码与原码相同；负数的补码等于其反码+1；</div></pre></td></tr></table></figure></p>
<p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1100110011 原</div><div class="line">1011001100 反，除符号位外，其它按位取反</div><div class="line">1011001101 补，反码+1</div></pre></td></tr></table></figure></p>
<h1 id="分支-循环"><a href="#分支-循环" class="headerlink" title="分支/循环"></a>分支/循环</h1><p><strong>分支：</strong>主要用于流程控制，判断用，常见主要为if、switch结构；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(表达式)&#123;</div><div class="line">        </div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式)&#123;</div><div class="line"></div><div class="line">        </div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span>(表达式/变量)&#123; </div><div class="line">       </div><div class="line">    <span class="keyword">case</span> 情况<span class="number">1</span>:</div><div class="line">        </div><div class="line">        语句块<span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">        </div><div class="line">    <span class="keyword">default</span>：</div><div class="line">          </div><div class="line">        默认情况语句块;  </div><div class="line">          </div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>三目运算符：</strong>表达式 ? 结果1:结果2</p>
<p><strong>循环：</strong>通常有for、while、do-while三种形式；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(初始化；表达式；循环变量)&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">while</span>(表达式)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">while</span>(表达式);</div></pre></td></tr></table></figure></p>
<p><strong>break：</strong>退出循环<br><strong>continue：</strong>跳出本次循环、进入下一次<br><strong>goto 标识符：</strong>无条件转移语句、可使程序立即跳转到函数内部的任意一条可执行语句.可用于退出循环.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">goto show;        //将转到sayhi函数中的show之后代码块执行.</div><div class="line">void  sayhi()&#123; show:  代码块&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> <code>在c语言中1代表true，0代表false. 因此可将数字或变量作为条件表达式.</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p><strong>数组:</strong>主要用于存储一组相同数据类型的数据集合.</p>
<p><strong>声明:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int arr[5];        //可不指定长度，内存首地址就是数组名或&amp;arr[0]</div><div class="line">char ch[];</div></pre></td></tr></table></figure></p>
<p><strong>初始化：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ch[0] = &apos;a&apos;;                            //逐个赋值a，ch[1]...</div><div class="line">char ch[5] = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;; </div><div class="line">int  numAttr[] = &#123;5,3,21,12,32&#125;;          //静态初始化,自动长度</div></pre></td></tr></table></figure></p>
<h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p><strong>字符数组：</strong>在c语言中，通常使用char[]，或char*来存储字符串，且会在末尾追加\0作为结束标记，长度需要+1；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char str[] = &quot;hello world&quot;;     //可采用字符串方式赋值</div><div class="line">char str[12] = &quot;hello world&quot;;      //若指定长度则需要12，因为还有\0</div><div class="line">char str[11] = &#123;&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos; &apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d’&#125;;   //不是字符串，不会有\0</div></pre></td></tr></table></figure></p>
<p><strong>字符数组的输入：</strong></p>
<p><code>scanf(&quot;%s&quot;,str);  //读取字符串到数组，首地址就是数组名</code></p>
<p><strong>字符数组的输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printf(&quot;%s&quot;,str);     //输出字符数组内容，也可通过&amp;str[0]</div><div class="line">printf(&quot;%c&quot;,str[0]);  //输出指定字符</div></pre></td></tr></table></figure></p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>可在声明式进行初始化:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int  arr[2][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;  //使用多个括号分割、建议使用.</div><div class="line">int  arr[2][2] = &#123;1,2,3,4&#125;;           //2行2列、自动按照行列顺序进行排列</div><div class="line">赋值： arr[rowIndex][colIndex] = 值;</div></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><strong>说明:</strong>是完成特点任务的代码块，将程序分为若干个模块，实现代码复用、可扩展性等.</p>
<p><strong>标准做法：</strong>先提供函数原型再实现，但如果函数位于调用者之前，则可以省略声明函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明函数原型，标准做法需要void</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eat</span><span class="params">(<span class="keyword">void</span>)</span></span>;   </div><div class="line">   </div><div class="line"><span class="comment">//实现Eat函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span></span>&#123;          </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"this function is eat"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>形参/实参：</strong><br><strong>形参：</strong>形式上的参数、没有值、声明.由外界传入实参赋给形参. 如果不需要参数在函数体内被修改，可加上const修饰.<br><strong>实参：</strong>有实际值的参数、传入方法、赋给形参.</p>
<p><strong>值传递/引用传递：</strong><br><strong>值传递：</strong>对于基本数据类型int double等，传参时会将值赋值一份传入. 因此在函数体无论如何修改，都不会影响到原值.<br><strong>引用传递：</strong>如数组等作为参数，则传递的是地址，因此函数体内进行的操作，会对原来数组产生影响.</p>
<p><strong>返回值：</strong>函数返回给外界使用的一个值. </p>
<p><strong>局部变量：</strong>作用域为定义它的代码块内部.   即{};<br><strong>全局变量：</strong>不属于函数、而属于整个源文件. 如果外部文件需要引用则需要extern修饰</p>
<p><strong>内部函数：</strong>指函数只在其所在源文件中使用， 又称为静态函数.<br><code>static  返回值  函数名 ([参数列表]);</code>      //加上此关键字即可.</p>
<p><strong>外部函数：</strong>可被外部文件调用的函数.<br><code>extern  返回值  函数名([参数列表]);</code>       //默认的、因此可省略extern关键字.</p>
<p><strong>递归：</strong>函数自己调用本身. 注意每次调用完本身后会返回接着执行；</p>
<h2 id="常见系统函数"><a href="#常见系统函数" class="headerlink" title="常见系统函数"></a>常见系统函数</h2><p><strong>通常引用c函数库的方式有三种：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 自动访问，常见的函数     </div><div class="line">2. #include文件包含  </div><div class="line">3. 库包含如.so、.dll程序集等</div></pre></td></tr></table></figure></p>
<p><strong>math.h（数学类）：</strong></p>
<pre><code>int abs(int i);      long labs(long l);   double  fabs(double d);
sin(double d);       cos(double  d);      tan(double  d);  
</code></pre><p><strong>ctype.h（字符类）：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">isalpha</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;       <span class="comment">//检测是否为字母. 不是返回0false、是返回非0-》true</span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">isdigit</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;       <span class="comment">//检测是否为数字、是则返回非0。不是返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">isalnum</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;       <span class="comment">//检测是否为字母或数字.</span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">islower</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;       <span class="comment">//小写字母</span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">isupper</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;       <span class="comment">//大写字母</span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">tolower</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;              <span class="comment">//转小写 </span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">toupper</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;              <span class="comment">//转大写</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isspace</span><span class="params">(<span class="keyword">int</span>  ch)</span></span>;      <span class="comment">//是否为空白字符</span></div></pre></td></tr></table></figure></p>
<p><strong>stdlib.h（系统类）：</strong><br>    exit(1);             //用于终止程序</p>
<p><strong>string.h（字符串处理类）：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* p1，<span class="keyword">char</span>* p2)</span></span>;   <span class="comment">//将p2复制到p1指向的位置(前面). 返回值是p1;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* p1，<span class="keyword">char</span>*p2)</span></span>;   <span class="comment">//将p2追加到p1字符串后面。返回p1</span></div><div class="line"> </div><div class="line"><span class="comment">//两个字符串从首字母按照编码表开始比较. 0：相等    正数：p1&gt;p2   负数：p1&lt;p2</span></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span>* p1，<span class="keyword">char</span>* p2)</span></span>;   </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strupr</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;      <span class="comment">//转大写</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strlwr</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;      <span class="comment">//转小写</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">sizeOf</span><span class="params">(<span class="keyword">void</span> * str)</span></span>;      <span class="comment">//获取空间(数组，数据类型，指针等)的字节大小.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">strlen</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;      <span class="comment">//获取字符串长度int  len = strlen(“hello world”);</span></div></pre></td></tr></table></figure></p>
<h2 id="输入-输出函数"><a href="#输入-输出函数" class="headerlink" title="输入/输出函数"></a>输入/输出函数</h2><p><strong>简介：</strong>主要用于接收用户输入、并返回运算结果的函数</p>
<p><strong>常见转义符：</strong>在c、java、php中皆以\反斜杠为转义符，在.net中通常使用@符号；<br>    \n：换行              \t：制表位         \b：退格              \r：回车<br>    \：反斜杠         \’：单引号            \a：警报</p>
<p><strong>字符类：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;         <span class="comment">//输出单个字符并将其返回；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;               <span class="comment">//从输入队列中获取一个字符. 可读取空白字符；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">puts</span><span class="params">(<span class="keyword">char</span> * str)</span></span>;      <span class="comment">//输出字符串并自动换行</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span> * str)</span></span>;     <span class="comment">//从键盘录入一行字符串，返回读取后的字符指针.</span></div></pre></td></tr></table></figure></p>
<p><strong>格式化类：</strong></p>
<ul>
<li>int printf(格式控制，输出列表);   //返回输出的字符个数.</li>
<li>int scanf(格式控制，地址列表);    //成功返回读入的字段个数. 错误则返回0.</li>
</ul>
<p><strong>注意：</strong><br>    1，格式说明符和参数类型必须正确，否则会造成数据错乱<br>    2，为避免内存溢出，scaf将自动忽略空白字符，并用其分隔相邻的输入项，因此存储字符串时建议使用gets函数；</p>
<p><strong>常见格式说明符：</strong></p>
<pre><code>%d：十进制         %0：八进制            %x：十六进制
%hd：短整型        %ld：长整型           %hu：无符号短整型
%f：单/双精度      %lf：长双精度         %.mf：精确到小数点m位
%e：指数          %c：字符              %s：字符串
%p：指针、地址.    %%：输出百分号
</code></pre><p><strong>指定宽度，并补齐空格：</strong></p>
<p><strong>%m.nf：</strong> <code>浮点数长度为m，并精确到小数点n位.</code><br><strong>%ms： </strong> <code>长度不足m，则右对齐，左补空格，否则全部输出例：</code><br>   <code>printf(&quot;this is %10s&quot;,&quot;love&quot;);结果为[     love]</code><br><strong>%-ms：</strong> <code>同上，但是左对齐，右补空格</code><br><strong>%m.ns：</strong> <code>表示输出字符占m列、但是只取字符串左侧n个字符、且输出在右侧、左补空格例如：</code><br>   <code>printf(&quot;%10.3s&quot;,&quot;love&quot;);        结果：      lov</code><br><strong>%-m.ns：</strong> <code>同上左对其，右补空格.</code><br>    printf(“asdas””zxczx”);  //解决一行数据过多的办法. 使用2个双引号即可.</p>
<p><strong>常见标志：</strong><br>    -：左对齐，可和格式说明符结合使用,左右补空格等. 例如：printf(“%-s”,”isfosdjfo”);<br>    +：正数则显示+号，负数显示-号. 如：printf(“%+d”,32);    printf(“%+d”,-32);<br>    空格：正数显示空格，负数显示-;  如：printf(“% d”,-32);</p>
<pre><code>#：转换可选形式.   %0  %x  用于输出八进制或十六进制.
*：如果不事先指定字段宽度而希望是由程序来决定，可在字符宽度部分使用*来代替. 
</code></pre><p><strong>数据重定向：</strong>可在命令行使用，在unix、linux、ds下还可使用更复杂的运算符；<br><strong>输入重定向：</strong>&lt; 代表输入来自文件，而不是键盘. 作为一个字符流传入.<br><strong>输出重定向：</strong>&gt; 将其程序的输出到指定文件中.  .</p>
<p><strong>缓冲区：</strong>getchar、gets、printf等IO函数时，会先存储到缓冲区，当按下回车键后才对程序变为可用，也可\n强制刷新缓冲区；</p>
<p><strong>缓冲分为两种：</strong><br><strong>完全缓冲：</strong> <code>缓冲区装满时被清空，此种类型通常出现在文件输入输出中. 缓冲区大小取决于系统.</code><br><strong>行缓冲：</strong>  <code>遇到一个换行字符时清空缓冲区(发送到目的地)，例如键盘输入，按下回车键将清空.</code></p>
<p><img src="http://devfqh.com/images/C/chapter_one20.png" alt="">          </p>
<p><strong>总结：</strong><br>    1，作为标准i/o包下的getchar scanf函数检测到文件末时候都返回EOF<br>    2，如果混合使用getchar和scanf，则在调用getchar之前，恰好有scanf在输入队列中留下换行符时，可能产生对程序错误的问题，需要进行判断</p>
<h2 id="main-函数解析"><a href="#main-函数解析" class="headerlink" title="main 函数解析"></a>main 函数解析</h2><p>main函数是 c 程序的入口,其可不带参数或带2个参数,参数个数和字符串数组.由古老的命令行系统中传入.如linux dos 下执行格式:</p>
<p><em>文件名字符参数; </em>  多个字符参数使用空格隔开<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(intargc,<span class="keyword">char</span> *argv[])</span></span>&#123;  <span class="comment">//默认传入编译后可执行文件路径</span></div><div class="line">       <span class="built_in">printf</span>(<span class="string">"参数个数：%d\n"</span>,argc);</div><div class="line">       <span class="built_in">printf</span>(<span class="string">"参数名称：%s"</span>,*argv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><img src="http://devfqh.com/images/C/chapter_one21.png" alt=""> </p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针入门"><a href="#指针入门" class="headerlink" title="指针入门"></a>指针入门</h2><p><strong>指针：</strong>就是一种变量类型，专门用于存储内存单元的地址，可通过其访问内存单元，操作数据；</p>
<p><strong>语法：</strong>  <code>数据类型  *指针名；</code><br><strong>赋值：</strong>通过&amp;赋予地址，注意指针本身也有地址，同样通过&amp;；</p>
<p><strong>示例：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">99</span>;  </div><div class="line"></div><div class="line"><span class="keyword">int</span> *p;                    <span class="comment">//定义一个int类型的指针变量</span></div><div class="line"></div><div class="line">p = &amp;num;                   <span class="comment">//指针变量指向了num的地址.</span></div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,*p);           <span class="comment">//输出值. 加上*号代表输出指针指向的值.</span></div></pre></td></tr></table></figure></p>
<p><strong>&amp;：</strong> <code>地址运算符，返回数据变量的地址.</code><br><strong>*：</strong> <code>指针运算符，返回指针变量指向地址的内存单元中存储的值(数据).</code></p>
<pre><code>*p = 123;    //可为指针指向的地址内存中存储的值进行操作.
*p = *p2;    
</code></pre><p><strong>&amp;和*优先级相同，因此从右往左执行：</strong><br>    printf(“%d “,&amp;<em>p);       //</em>获得指针p指向的值,在通过&amp;获得指向值的地址.</p>
<p><strong>指针自增自减运算：</strong>指向下一个内存单元，对于数组而已，会指向下一个元素地址，int（4字节）、short（2字节）、short（直接输出值，而不是地址）</p>
<p><img src="http://devfqh.com/images/C/chapter_one22.png" alt=""> </p>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p><strong>简介:</strong>数组本质就是连续的存储空间,且数组名称就是数组在内存的首地址,即arr = &amp;arr[0],因此可对指针就自增/自减,来完成迭代数组.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> *p;        <span class="comment">//指针变量</span></div><div class="line"></div><div class="line">p = arr;       <span class="comment">//获取数组的首地址，也可通过&amp;arr[0]</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>,*(p+i));      <span class="comment">//*p++ == *(arr+i)  == *(&amp;arr[0]+i) 皆可指向下一个内存单元</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>通过两个指针来完成迭代：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c  while(start &lt;= end)   或  while(start != end)</div></pre></td></tr></table></figure></p>
<p><strong>const和指针：</strong><br>     1，const int<em> p1;    //const放在前面，可改变指向的地址，但不可改变指针执行的值
          </em>p1 = 18;          //错误<br>          *p1 = &age;         //正确 </p>
<pre><code>2，int const* p2;    //const放在后面，可改变指向值，但不可改变指针执行的地址
      *p2 = 18;          //正确
      *p1 = &amp;age;         //错误 

3，const int* const p3 = &amp;age;  //两个const，则即不可改变指针执行地址、也不可改变指针执行的值
</code></pre><p><strong>指针数组：</strong>即数组中存放的元素都是指针，最常见为char字符指针数组，分别存储一个字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int *p_arr[3];      int (*p_arr)[3];</div><div class="line"></div><div class="line">//通过二位字符数组，来存储字符串，不建议使用，大小固定</div><div class="line">char ch[4][10] = &#123;"hello","world","servlet","asp.net”&#125;;</div><div class="line"></div><div class="line">//建议使用，每个char*来存储字符串</div><div class="line">char *month[] = &#123;"one","two","three","four"&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h2><p><strong>字符串与指针：</strong>c语言中没有对字符串的封装，可通过字符数组、字符指针来完成；会在末尾加上\0标识；<br>    char  str[] = “hello”;      //字符数组，可指定长度，用于存储字符串<br>    char  <em>p = “world”;         //字符指针，指向字符串首个字符地址.<br>    char </em> month[] = {“one”,”two”,”three”,”four”};   //字符指针数组</p>
<p><strong>使用：</strong>两者使用基本相同，可使用下标，也可当做指针进行操纵：str[1];  p[1]; str++; p++;</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>函数指针：</strong>通常作为参数使用，并作为回调函数，需提供函数原型、函数名为首地址；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1，声明函数原型</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="built_in">string</span> str)</span></span>;    </div><div class="line">   </div><div class="line"><span class="comment">//2，函数指针，将函数名赋予即可，格式：返回值 (*指针名) (参数类型) = 函数名;</span></div><div class="line"><span class="keyword">void</span> (*p) (<span class="built_in">string</span>) = sayHi; </div><div class="line"> </div><div class="line"><span class="comment">//3，调用</span></div><div class="line">p(参数) == (*p) (参数);</div></pre></td></tr></table></figure></p>
<p><strong>通常是作为参数，并进回调，格式如下：</strong><br>     void show(void (*p) (string));</p>
<p><strong>函数指针数组：</strong><br>    void(<em>p_arr[5]) (string);<br>    (</em>p_arr[index]) (arg);  </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例1：指向指针的指针：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">0</span>;    </div><div class="line"><span class="keyword">int</span>* p1 = &amp;num;     </div><div class="line"><span class="keyword">int</span>** p2 = &amp;p1; <span class="comment">//指向一个指针</span></div></pre></td></tr></table></figure></p>
<p><strong>示例2 - 指针变量做函数参数-交换值：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> temp = *a;       <span class="comment">//交换值操作</span></div><div class="line">  *a = *b;            <span class="comment">//*：指针指向地址中存放的数据. 不是操作地址.</span></div><div class="line">  *b = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> x = <span class="number">80</span>,y = <span class="number">90</span>;</div><div class="line">  <span class="keyword">int</span> *p_x = &amp;x, *p_y = &amp;y;       <span class="comment">//两个指针分别指向x y的地址</span></div><div class="line">  swap(p_x,p_y);       <span class="comment">//传入指针、内部对指向地址的数据进行了交换. 直接影响到了变量 x y</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>,x);       <span class="comment">//输出</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"y = %d\n"</span>,y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>示例3 - 指针完成冒泡排序：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过指针、实现冒泡排序；指针p代表数组的首地址</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderby</span><span class="params">(<span class="keyword">int</span> *p,intlen)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i,j,temp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;</div><div class="line">       <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; len - i <span class="number">-1</span>; j++)&#123;</div><div class="line">           <span class="keyword">if</span>(*(p+j) &gt; *(p+j+<span class="number">1</span>))&#123;      <span class="comment">//交换值操作、*代表指针地址对应的数据</span></div><div class="line">              temp = *(p+j);</div><div class="line">              *(p+j) = *(p+j+<span class="number">1</span>);</div><div class="line">              *(p+j+<span class="number">1</span>)  = temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(p+i));    <span class="comment">//打印、从首地址开始.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">15</span>,<span class="number">32</span>,<span class="number">54</span>,<span class="number">67</span>&#125;;</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">    p = arr;          <span class="comment">//将首地址赋给指针。等价于：p = &amp;arr[0];</span></div><div class="line">    orderby(p,<span class="number">10</span>);    <span class="comment">//排序</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="结构体、共用体、枚举"><a href="#结构体、共用体、枚举" class="headerlink" title="结构体、共用体、枚举"></a>结构体、共用体、枚举</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><strong>结构体：</strong>构造类型，用于存储一组不同数据类型的结构；（可理解面向对象中，为轻量级的类）<br><strong>语法：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDate</span>&#123;</span>           <span class="comment">//定义一个结构</span></div><div class="line"> <span class="keyword">int</span> year;</div><div class="line"> <span class="keyword">int</span> month; </div><div class="line"> <span class="keyword">int</span> day;          </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDate</span> <span class="title">d1</span>;</span>     <span class="comment">//创建一个结构变量，并使用</span></div><div class="line">d1.year = <span class="number">2010</span>;</div></pre></td></tr></table></figure></p>
<p><strong>特殊语法：</strong></p>
<ul>
<li>1，可在声明结构体时，创建结构体变量*</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDate</span>&#123;</span></div><div class="line"> <span class="keyword">int</span> year;</div><div class="line"> <span class="keyword">int</span> month; </div><div class="line"> <span class="keyword">int</span> day;          </div><div class="line">&#125; d1,d2,d3</div></pre></td></tr></table></figure>
<p>   <em>2，结构体变量的初始化</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDate</span> <span class="title">d1</span> = &#123;</span><span class="number">2010</span>,<span class="number">10</span>,<span class="number">10</span>&#125;；  </div><div class="line">d1.year = <span class="number">2010</span>;</div></pre></td></tr></table></figure></p>
<p>   <em>3，结构体也可作为数组，例如</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDate</span> <span class="title">days</span>[3] = &#123;</span>&#123;<span class="number">2010</span>,<span class="number">10</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2010</span>,<span class="number">10</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2010</span>,<span class="number">10</span>,<span class="number">10</span>&#125;&#125;;</div><div class="line">day3[<span class="number">0</span>].year;   <span class="comment">//访问方式</span></div></pre></td></tr></table></figure></p>
<p><strong>结构体指针：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct MyDate today;     //创建一个结构变量,并赋值</div><div class="line"></div><div class="line">today.year = 2010; </div><div class="line">today.month = 10; </div><div class="line">today.day = 1; </div><div class="line">struct MyDate *p = &amp;today;  //创建一个结构指针，并通过&amp;指向today</div><div class="line"></div><div class="line">p-&gt;day;      //通过-&gt;指针运算符直接调用</div><div class="line">(*p).day;    //通过*寻址运算符，再通过.调用</div></pre></td></tr></table></figure></p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p><strong>说明：</strong>使用类似于struct，其关键字为union，为所有共用体变量所共享，当某个共用体变量的成员改变，其它的成员也会改变；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> Person&#123;</div><div class="line">  <span class="keyword">int</span> id;           <span class="comment">//注意共用体中成员数据是相同的. 二个进制位</span></div><div class="line">  <span class="keyword">char</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">union</span> Person person = &#123;<span class="number">97</span>&#125;;       <span class="comment">//创建共用体变量，并初始化为id赋值97</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>,person.name);       <span class="comment">//输出a，共用体内成员数据共享的. name == id == 97;</span></div><div class="line"></div><div class="line">    person.name=<span class="string">'A'</span>;            <span class="comment">//将name改成’A’，则id也会变成’A’的ascii码</span></div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,person.id);     <span class="comment">//输出65</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><strong>enum：</strong>用于存放一组相关的数据，且每个标识符都对应一个整数，称为枚举常量，使用与struct、union类似，需定义枚举变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个枚举</span></div><div class="line"><span class="keyword">enum</span>  Colors&#123;</div><div class="line">    Red,Green,Blue</div><div class="line">&#125; c1,c2;         </div><div class="line"></div><div class="line"><span class="comment">//枚举常量</span></div><div class="line"><span class="keyword">enum</span>  Colors&#123;</div><div class="line">    Red=<span class="number">1</span>,Green=<span class="number">2</span>,Blue=<span class="number">3</span></div><div class="line">&#125;;   </div><div class="line"></div><div class="line"><span class="keyword">enum</span> Colors c = Red;         <span class="comment">//定义一个枚举变量，其值只能是Red、Green、Blue</span></div></pre></td></tr></table></figure></p>
<p><strong>位段：</strong>特殊的结构类型，用于一些特殊场合，其所有成员的长度均是以二进制位为单元定义的，结构中的成员称为位段.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuStatus</span>&#123;</span></div><div class="line">    <span class="keyword">unsigned</span> sign:<span class="number">1</span>;     <span class="comment">//符号标志</span></div><div class="line">    <span class="keyword">unsigned</span> zero:<span class="number">1</span>;     <span class="comment">//零标志</span></div><div class="line">    <span class="keyword">unsigned</span> carry:<span class="number">1</span>;    <span class="comment">//进位</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p><strong>简介：</strong>C程序在编译前会先经过一个预处理的过程，用于#inclde包含文件，宏替换，特殊符号的处理等，再变成一个.i文件，预处理指令以#号开头.</p>
<h2 id="include（包含指令）"><a href="#include（包含指令）" class="headerlink" title="#include（包含指令）"></a>#include（包含指令）</h2><p><strong>简介：</strong> <code>包含指令，用于包含另外一个源文件的内容；</code><br><strong>&lt; &gt;：</strong> <code>系统到存放c函数库头文件所在的目录中查找，标准方式.</code><br><strong>“ “：</strong> <code>先在用户指定目录中寻找，若找不到，再到存放c函数库头文件所在的目录中查找.</code></p>
<p><strong>.h头文件：</strong> <code>本质就是.c源程序，通常存储宏定义、函数原型、常量、typeof、结构、枚举、外部函数等. 之后在其它程序通过#include指令引入使用即可.</code></p>
<h2 id="define（宏定义）"><a href="#define（宏定义）" class="headerlink" title="#define（宏定义）"></a>#define（宏定义）</h2><p><strong>简介：</strong> <code>宏定义，即字符串常量，仅作替换，不分配内存空间；</code><br><strong>语法： </strong> <code>#define  宏名[(参数列表)]  字符串;    //可使用”” ‘’</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.141592;        <span class="comment">//不带参数的宏</span></span></div><div class="line">.</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(a,b) (a+b);         <span class="comment">//定义一个带参数的宏，本质就是一个函数</span></span></div><div class="line">    <span class="keyword">int</span> x = <span class="number">10</span> ,y = <span class="number">20</span>;       </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>,SUM(x,y))</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> PI;     <span class="comment">//终止宏定义</span></span></div></pre></td></tr></table></figure></p>
<p><strong>ANSI标准说明了5个预定义宏替换名：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_LINE_：当前被编译代码的行号</div><div class="line">_FILE_：当前源程序的文件名称</div><div class="line">_DATE_：当前源程序的创建日期</div><div class="line">_TIME_：创建时间</div><div class="line">_STDC_：判断当前编译器是否为标准c.    1 = 符合标准c；</div></pre></td></tr></table></figure></p>
<h2 id="if、-elif、-else（条件编译）"><a href="#if、-elif、-else（条件编译）" class="headerlink" title="#if、#elif、#else（条件编译）"></a>#if、#elif、#else（条件编译）</h2><p><strong>条件编译：</strong>当某些代码在满足条件下，才进行编译，否则跳过；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span>  表达式1                <span class="comment">//此种类似于if else if结构.</span></span></div><div class="line">  代码块</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span>  表达式2</span></div><div class="line">   代码块</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">   代码块</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 宏替换名       <span class="comment">//如果定义此宏、则编译。否则不编译</span></span></div><div class="line"></div><div class="line">    代码块.</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<h2 id="line-error"><a href="#line-error" class="headerlink" title="#line #error"></a>#line #error</h2><p>#line：用于重置由<strong>LINE</strong>和<strong>FILE</strong>报告的行号和文件名.<br>#line 1000;             //将当前行号设置为1000<br>#iine 10 “cool.c”;       //将行号重置为10，文件名称重置为cool.c</p>
<p>#error：使预处理发出一个错误消息(异常)，之后编译过程中断.<br>    #error “不支持c99标准”; </p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>#pragma  参数;     //设定编译器状态，完成一些特定操作；<br>#pragmacomment(lib,”ws2_32.lib”)     //在socket编程中需要ws2_32.dll程序集.</p>
<p><strong>常见参数：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">message，能够在编译信息输出窗口中输出相应的信息</div><div class="line">Code_Seg：设置程序中函数代码存放的代码段</div><div class="line">Once：保证头文件被编译一次</div><div class="line">Comment：可导入程序集，动态链接库德国.</div></pre></td></tr></table></figure></p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a>FILE</h2><p><strong>标准I/O包：</strong>stdio.h头文件，提供了大量函数用于输入/输出<br><strong>简介：</strong>C程序自动打开3个文件，标准输入，标准输出，标准错误输出.</p>
<p><strong>FILE：</strong>结构体变量，包含了文件名，状态，位置，大小等信息，通常使用此指针来描述文件信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></div><div class="line">  <span class="keyword">short</span>           level;          <span class="comment">/* fill/empty level of buffer */</span></div><div class="line">  <span class="keyword">unsigned</span>        flags;          <span class="comment">/* File status flags    */</span></div><div class="line">  <span class="keyword">char</span>            fd;             <span class="comment">/* File descriptor      */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>   hold;           <span class="comment">/* Ungetc char if no buffer */</span></div><div class="line">  <span class="keyword">short</span>           bsize;          <span class="comment">/* Buffer size          */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>   *buffer;        <span class="comment">/* Data transfer buffer */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>   *curp;          <span class="comment">/* Current active pointer */</span></div><div class="line">  <span class="keyword">unsigned</span>        istemp;         <span class="comment">/* Temporary file indicator */</span></div><div class="line">  <span class="keyword">short</span>           token;          <span class="comment">/* Used for validity checking */</span></div><div class="line">&#125; FILE;                           <span class="comment">/* This is the FILE object */</span></div></pre></td></tr></table></figure>
<p>FILE  * fp;       //文件指针指向了FILE(结构体变量)，可通过其操作文件.</p>
<p><strong>文件的打开模式：</strong></p>
<p><img src="http://devfqh.com/images/C/chapter_one23.png" alt=""></p>
<p><strong>EOF：</strong>通常用于判断文件末尾，其值为-1；#define定义</p>
<h2 id="打开-关闭文件"><a href="#打开-关闭文件" class="headerlink" title="打开/关闭文件"></a>打开/关闭文件</h2><pre><code>FILE * fp = fopen(&quot;c:\\a.txt&quot;,&quot;r”);   //成功返回FILE指针，失败返回NULL

fclose(文件指针);                     //关闭成功返回0，失败返回EOF.
</code></pre><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><p><strong>字符：</strong><br>    fputc(int i，FILE <em>fp);      //写入字符，成功返回写入字符数，失败返回EOF<br>    fgetc(FILE </em>fp);             //读取一个字符，当读到末尾时返回结束标志EOF<br>    getc(FILE *fp);              //也可实现从指定文件读取一个字符、末尾返回EOF</p>
<p><strong>字符串：</strong><br>    fputs(char <em> str，FILE </em>fp);     //写入字符串，成功返回写入的字符数，失败返回EOF<br>    fgets(char <em> str，int len，FILE </em>fp);  //读取len长度的字符串，到str中. 末尾返回EOF</p>
<h2 id="格式化读写文件"><a href="#格式化读写文件" class="headerlink" title="格式化读写文件"></a>格式化读写文件</h2><p>fprintf(文件指针，格式字符串，输出列表);<br>    fprintf(fp,”%d”,i);    //将整型变量i，输出到fp指向文件中.</p>
<p>fscanf(文件指针，格式字符串，输入列表);<br>    fscanf(fp,”%d”,&amp;i);    //从fp中读取一个字符，存到变量i</p>
<p>//从fp指向文件读入count次，每次读size字节，存储到buffer地址中.<br>fread(buffer,size,count,fp);   </p>
<p>//将buffer开始写入count次，每次写size个字节到fp所指文件中.<br>fwrite(buffer,size,count,fp); </p>
<p><strong>参数说明：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">buffer：一个指针，输出/输入地址</div><div class="line">size：每次读取字节数</div><div class="line">count：读取多少次</div><div class="line">fp：文件指针</div></pre></td></tr></table></figure></p>
<p><strong>示例-读取：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">char</span> arr[<span class="number">20</span>];</div><div class="line">FILE * fp = fopen(<span class="string">"E:\\遇见未知的自己.txt"</span>,<span class="string">"r++"</span>);</div><div class="line"><span class="keyword">if</span>(fp != <span class="literal">NULL</span>)&#123;</div><div class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</div><div class="line">       fread(&amp;arr[i],<span class="number">1</span>,<span class="number">20</span>,fp);<span class="comment">//从fp指向文件中读取20次，每次读取1个字节存到字符数组</span></div><div class="line">   &#125;</div><div class="line">   fclose(fp);       <span class="comment">//关闭资源</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,arr);</div></pre></td></tr></table></figure></p>
<p><strong>示例-写入：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</div><div class="line">  fwrite(&amp;arr[i],<span class="number">20</span>,<span class="number">1</span>,fp); <span class="comment">//从fp指向文件中写入20次，每次将arr数组的数据，写入1个字节.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>fseek(文件指针，位移量，起始点);   //0：文件头   1：当前位置  2：文件末</p>
<p><strong>示例：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * str = <span class="string">"hello world"</span>;</div><div class="line">fseek(fp,<span class="number">5l</span>,<span class="number">0</span>);             <span class="comment">//将文件指针指向距文件头后5个字节的位置. 负数则之前.</span></div><div class="line">fgets(str,<span class="keyword">sizeof</span>(str),fp);  <span class="comment">//再次进行读取字符串</span></div></pre></td></tr></table></figure></p>
<p><strong>结果：</strong>world</p>
<p><code>int rewind(文件类型指针);</code>    //使位置指针重新指向文件头<br><code>long ftell(文件类型指针);</code>   //得到流式文件中的当前位置，相对于文件头的位移量. 当返回-1l则出错</p>
<p>对于文件复制，可有多种方式如fread  fwrite  fseek等皆可.</p>
<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="存储管理-1"><a href="#存储管理-1" class="headerlink" title="存储管理"></a>存储管理</h2><p><strong>变量的存储类别：</strong> <code>从变量的产生时间可分为静态存储和动态存储.</code><br>  <strong>静态存储：</strong> <code>指程序运行前分配的固定存储方式.</code><br>  <strong>动态存储：</strong> <code>指程序运行期间根据需要动态的分配存储空间.</code></p>
<p><strong>可通过存储修饰符来指定存储类型变量：</strong><br><strong>1.    auto： </strong>修饰一个局部变量为自动，默认的，每次只需到定义变量的代码行时，会产生并初始化<br><strong>2.    register：</strong>存储在计算器的某个硬件寄存器而不是内存，可提高程序的运行速度，程序员无法获取寄存器变量的地址，不常用；<br><strong>3.    static：</strong>在程序运行期间，其值始终有效，但是限定该全局变量只能在定义它的文件中使用；<br><strong>4.    extern：</strong>外部存储变量、声明此变量由外部定义的，由于一个c程序可能有多个文件、因此可使用extern来提供给其它文件使用.</p>
<pre><code>extern int numExtern = 888;        //文件1
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;   </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> numExtern;        <span class="comment">//使用extern来引用外部变量</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,numExtern);   <span class="comment">//此处将输出888</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>简介：</strong>static和extern也可作用于函数，且注意c语言中全局变量的定义是有顺序关系的；</p>
<p><strong>外部函数：</strong>当前文件的函数允许被其它文件的函数访问、调用，即称为外部函数，默认就是extern<br><strong>静态函数：</strong>又称内部函数，使用static修饰之后，则可定义该函数的文件中使用；</p>
<p><strong>程序通常要先装载到计算机的内核与半导体内存中，再运行程序. 程序被组织成4个逻辑段.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，可执行代码和静态数据：被存储在固定的内存位置</div><div class="line">2. 动态数据（堆）：程序请求动态分配的内存来自内存池，也就是堆.</div><div class="line">3. 栈：程序不会像堆那样动态分配内存，当程序调用函数，或声明变量时，系统会自动分配内存. 是一个先进后出的数据结构;</div></pre></td></tr></table></figure></p>
<p><strong>类型限定词：</strong> <code>const</code><br><strong> volatile：</strong> <code>告诉编译器该变量除可被程序改变之外，还可被其它代理改变，如硬件等.</code><br><strong> restrict：</strong> <code>只可用于指针，表明指针是访问一个数据对象的唯一方式.</code></p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>动态内存分配：</strong>malloc、calloc、free，需引入 <stdlib.h> ，返回值为 void * 代表通用指针</stdlib.h></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分配一个size大小的空间，返回该内存地址，可赋予指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">(unsignedint size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//重新改变一个指针的内存大小,并返回该指针（本质是先释放、再分配）</span></div><div class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">(<span class="keyword">void</span> *p , unsignedint size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//动态分配n个长度为size的连续内存空间数组，并返回指针，为数组的首地址，错误返回NULL</span></div><div class="line"><span class="function"><span class="keyword">void</span> * <span class="title">calloc</span><span class="params">(<span class="keyword">unsigned</span> n,<span class="keyword">unsigned</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//释放由指针p指向的内存空间，使其内存区域可用，是通过calloc或maloc函数时返回的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</div></pre></td></tr></table></figure>
<p><strong>sizeof：</strong>返回类型的大小，例如int占4个字节<br>    <code>size (int);</code><br>   <code>size (num)；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">int</span> * pArray;</div><div class="line">     <span class="keyword">int</span> i;</div><div class="line">     pArray = (<span class="keyword">int</span> *) <span class="built_in">calloc</span>(<span class="number">3</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">//分配3个连续存储的int空间，并且指向首地址</span></div><div class="line">     <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">        *pArray = <span class="number">10</span>*i;             <span class="comment">//使用指针对数组赋值</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d == %d \n"</span>,i,*pArray);   <span class="comment">//输出</span></div><div class="line">        pArray++;            <span class="comment">//移动指针指向下一个存储的数据的位置</span></div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>内存泄露：</strong>在使用了malloc、calloc等函数分配内存后，必须使用free函数进行释放，否则可能会因为内存没释放而造成内存泄露，从而导致系统奔溃.</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4,编译原理]]></title>
      <url>/2015/09/24/4-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong><em>备注：</em></strong>程序设计语言的编译时非常复杂的，对于应用层开发人员仅作略微了解即可，深入完全无意义。。即使是整个中国，也没有人能研发出一款真正的程序设计语言编译器；</p>
<p><strong>程序设计语言分类：</strong></p>
<p><strong>1，编译型：</strong>将整个源程序编译成机器语言，即二进制，计算机可直接运行，优点是速度快，缺点是跨平台性略差；<br><code>（例如c/c++，每次编译成可执行文件后，如果需要跨平台，需要再次通过链接变成相应平台的可执行文件）</code></p>
<p><strong>2，解释型：</strong>先将源程序编译编译成中间代码，运行时才一行一行解释成机器代码并执行，优点是跨平台性好，缺点速度慢，每次运行都要进行解释<br>      （例如java编译后为.class字节码，通过JVM运行时才翻译成机器代码）；</p>
<p><strong>编译器：</strong>即将高级语言翻译成计算机所能识别的机器语言指令，本质也是一个程序；</p>
<p><strong>编译器结构：</strong></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p102.png" alt="">  </p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p103.png" alt="">               </p>
<p><strong>示例：</strong>position = initial + rate * 60；语句的编译过程</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p104.png" alt=""></p>
<p><strong>1，词法分析器：</strong>编译的第一个阶段，主要对源程序的字符串进行扫描和分解，识别成符号流</p>
<p><strong>扫描阶段：</strong>负责将一些不需要生成词法单元的简单处理，例如删除注释、将多个连续空白字符压缩成一个<br><strong>词法分析阶段：</strong>较为复杂，是将扫描阶段的输出生成词法单元，包括</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p105.png" alt=""></p>
<p><strong>词法单元：</strong>由一个词法单元名和一个可选的属性组成</p>
<p><strong>模式：</strong>描述了一个词法单元的词素可能具有的形式，当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列，对于标识符合其它词法单元，模式是一个更加复杂的结构，其可与多个符号串进行匹配；</p>
<p><strong>词素：</strong>是源程序中的一个字符序列，其与某个词法单元的模式匹配，并被词法分析器识别为改词法单元的一个实例；</p>
<p><strong>词法单元的属性：</strong>可为任意类型的结构化数据，通过词法单元id与其关联；</p>
<p><code>position = initial + rate * 60语句的词法分析流程如下；</code></p>
<p><strong>position：</strong>一个词素（即变量），会被映射成词法单元<id，1>，其中id是表示标示符的抽象符号，而1指向符号表中position对应的条目，一个标识符对应的符号表条目存放该标识符有关的信息，例如名称和类型</id，1></p>
<p><strong>=：</strong>赋值符号，其不是一个变量，因此没有属性值，直接忽略即可</p>
<p><strong>initial：</strong>同为词素（即变量），会被映射成词法单元<id，2>，2是指向initial对应符号表条目</id，2></p>
<p><strong>+：</strong>非变量，直接被映射成词法单元&lt;+&gt;</p>
<p><strong>rate：</strong>同为词素（即变量），会被映射成词法单元<id，3>，2是指向rate对应符号表条目</id，3></p>
<p><strong>*：</strong>同样非变量，为运算符号，直接被映射成词法单元&lt;*&gt;</p>
<p><strong>60：</strong>常量，直接映射成词法单元<60>；</60></p>
<p><strong>经过词法分析后的符号流为：</strong><id，1> &lt;=&gt; <id，2> &lt;+&gt; <id，3> &lt;*&gt; <60></60></id，3></id，2></id，1></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p106.png" alt=""></p>
<p><strong>2，语法分析：</strong>根据变成程序语言的语法规则，对词法分析器生成的词法符号流进行分析，变成语法树，树中的每个内部节点表示一个运算步骤，而其子节点表示该运算的结果；</p>
<p><strong>3，语义分析：</strong>即通过语法树和符号表中的信息来检测源程序是否和编程语言定义的语义一样，同时也收集类型信息，并将这些信息存放在语法树或符号表中，以便有序的中间代码生成过程中使用；其中重要的部分就是进行数据类型检查，且会继续自动类型转换，例如将float转为double等….</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p107.png" alt="">    </p>
<p><strong>4，中间代码生成：</strong>在经历了词法分析、语法分析后，对于有程序设计语言，可能会构造出多个中间代码形式（主要用于跨平台），例如c会翻译成汇编代码，再通过链接变成不同平台的可执行程序，而java会翻译成.class字节码，再由JVM解释执行；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p108.png" alt="">   </p>
<p><strong>5，代码优化：</strong>即去除中间代码中多余、性能低的部分，例如60和60.00是一样的，那么通过60来替代60.00，就可消除不必要的浮点数运算（如反码、补码运算），又或者某些变量只被使用一次，那么可替换成更短的指令，例如</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p109.png" alt=""> </p>
<p><strong>6，目标代码生成：</strong>通过代码生成器，生成目标语言代码，如果目标语言是机器代码（即0和1），那么就必须为程序使用的每个变量选择寄存器和内存位置，例如使用寄存器R1和R2，翻译后的机器代码如下；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p110.png" alt="">              </p>
<p><strong>符号表管理：</strong>即记录源程序中使用的变量名字，并收集变量的有关信息，如数据类型，范围、参数数量、传递方法（如引用传递、值传递等）</p>
<p><strong>编译器构造工具：</strong>现代的软件开发环境通常都包含了语言编辑器、调试器、版本管理、程序描述器、测试管理等…</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -计算机基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3,计算机网络]]></title>
      <url>/2015/07/16/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><p><strong>计算机网络：</strong>是自印刷术以来，人类在通信方面最大的变革，网络是硬件和软件的组合，负责将数据从一个地方发送到另外一个地方；</p>
<p><strong>网络几个特性：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，性能：多种衡量方式，例如传输速率、带宽、吞吐量、响应时间等，其也依赖于用户数、传输介质、硬件能力、软件效率等；</div><div class="line">2，可靠性：数据传输的正确、发送故障频率、数据的恢复等</div><div class="line">3，安全：包括保护数据、防止非授权访问、顺坏修改等</div></pre></td></tr></table></figure></p>
<p><strong>网络分类：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，局域网（LAN）：通常是私有的，例如学校、宿舍、办公室等</div><div class="line">2，广域网（WAN）：提供长距离的数据、图像、音频、视频信息的传输，从地理位置上可能包括、国家、大洲、全球等</div><div class="line">3，城域网（MAN）：介于LAN和WAN之间，通常是提供一座城市的服务</div></pre></td></tr></table></figure></p>
<p><strong>互联网：</strong>如今很少见到独立的网络，当多个网络连接在一起时，它们就组成了互联网<br><strong>因特网：</strong>网络将许多计算机连接在一起，而许多网络再连接到一起，构成了因特网，最为庞大，是成千上万、上百个国家所组成，不断的加入，因此无法进行具体的统计；</p>
<p><strong>因特网的标准化工作：</strong>通常以RFC文档为标准，有三种RFC（建议标准、草案标准、因特网标准）</p>
<p><strong>因特网的组成：</strong>其内部虽然负责，但从工作方式上，可大致分为两大块<br><strong>1，边缘部分：</strong>由连接在因特网上的主机组成，即用户使用的部分，用于进行通信、传送数据、音频、视频、资源共享等<br><strong>2，核心部分：</strong>由大量网络和连接这些网络的路由器组成，是为边缘部分的主机提供服务的；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p69.png" alt="">          </p>
<p><strong>主机：</strong>为用户进行信息处理，例如传递数据<br><strong>路由器：</strong>负责转发分组，当收到一个分组时，会存储下来，然后将分组转发到下一个路由器，直到最终的目标；</p>
<p>网络通信通常是指，在主机A上的某个程序和运行在主机B上的某个程序进行通信，通常有两种方式<br><strong>1，客户/服务器模式：</strong>客户端作为请求方，而服务则负责处理客户端请求，提供服务<br><strong>2，对等连接：</strong>即p2p，两个主机都运行即可进行通信，没有客户端和服务器之分</p>
<p><strong>ip地址：</strong>用于表示网络上的设备，不易记住；通常使用主机名；<br><strong>端口：</strong>用于表示不同的进程；有效端口0~65535；其中0和1024是系统使用和保留端口</p>
<p><strong>对于下一代因特网的发展：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，下一代网际协议IPV6</div><div class="line">2，多协议标记交换MPLS等...</div></pre></td></tr></table></figure></p>
<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><strong>OSI（open  systems Interconnection）：</strong>即国际标准化组织ISO为了统一全世界的网络互联，所提出的网络互联标准，是法律意义上的国际标准；</p>
<p>但到了90年代，虽然OSI的标准已经制定出来，但由于因特网的发展迅速，基本无任何厂家生产出符合OSI标准的商业产品，因此OSI标准在市场方面也就失败了，即使覆盖全世界的因特网也未使用此标准；</p>
<p><strong>OSI标准其失败原因主要在于：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，OSI转接们缺乏实际的经验，且制定周期太长，因而导致OSI生成的设备没能及时进入市场</div><div class="line">2，OSI的层次划分不合理，有些功能在多个层次中重复出现</div><div class="line">3，OSI协议实现过于复杂，且运行效率低下</div></pre></td></tr></table></figure>
<p><strong>TCP/IP：</strong>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网协议，定义了网络互连的标准，是目前应用最广泛的网络协议，其将网络互联分为四层/五层，每一层都由下层所提供的协议来完成自己的需求；</p>
<p><strong>OSI、TCP/IP层次结构简介：</strong><br><code>1，OSI的七层协议结构概念清楚，理论完整，但其既复杂又不实用；</code><br><code>2，TCP/IP则不同，早期分为四层的体系结构，但由于其网络接口层并没有什么具体内容，因此结合了OSI和TCP/IP的优点，采取一种具有五层协议的体系结构；</code></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p70.png" alt=""></p>
<p><strong>TCP/IP五层体系结构简介：</strong>后续的介绍，均以TCP/IP五层体系为准<br><strong>应用层：</strong>体系结构的最顶层，用户与网络的接口，直接为用户的应用程序提供服务，如各种终端的应用，例如文件传输协议(ftp)、虚拟终端协议(telnet)、超文本连接协议(http)</p>
<p><strong>传输层：</strong>负责为两个主机中进程之间的通信提供服务，由于一个主机可同时运行多个进程，因此传输层还具有复用和分发的功能，复用就是多个进程可同时使用传输层提供的服务；分发就是传输层将收到的信息分别交付给上级应用层的进程，主要传输协议有TCP、UDP</p>
<p><strong>网络层：</strong>tcp/ip协议的核心，主要将传输层产生的报文和数据分组，并完成数据包从源主机到目标主机的发送，使用IP协议来区分不同主机，其使用了多组协议来完成，例如ICMP（因特网控制消息协议）可报告错误信息给计算机、ARP(地址解析协议）、RARP(地址反解析协议）；</p>
<p>路由的选择，即指定确定数据包的部分或全部路径，因为因特网是（LAN、WAN、MAN）的集合，因此从源到目的地的数据包发送可能是几个发送的组合：源-&gt;路由器、路由-&gt;多个路由器、路由器-&gt;目的地的发送；</p>
<p><strong>数据链路层：</strong>两个主机之间的数据传输，总是在一段一段的链路上进行的，也就是说两个相邻节点之间（主机与路由器、或路由器与路由器之间），传输数据时点对点的，因此就需要专门的链路层，在两个相邻节点传送数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点上进行透明传送；<br><strong>物理层：</strong>主要定义物理设备的标准，如网线、光纤接口、电压、线路。传输数据单位是bit（比特），也就是0和1；</p>
<p><strong>每层封装的数据单元叫法不同：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">应用层：称为数据（data）</div><div class="line">传输层：数据段（segment）</div><div class="line">网络层：数据包（packet）</div><div class="line">链路层：数据帧（frame）</div><div class="line">物理层：比特流（bits），即0和1</div></pre></td></tr></table></figure></p>
<p><strong>对于OSI中的表示层、会话层：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">表示层：处理数据编码的表示问题，以保证数据格式可被应用层所识别，数据压缩和加密都是其转换功能之一，即主要对接收的数据进行解释，转换成可识别的东西；如图片、mp3等</div><div class="line">会话层：通过传输端口建立数据传输通道</div></pre></td></tr></table></figure></p>
<h1 id="TCP-IP-–-物理层"><a href="#TCP-IP-–-物理层" class="headerlink" title="TCP/IP – 物理层"></a>TCP/IP – 物理层</h1><p><strong>简介：</strong>TCP/IP最底层的协议，主要是定义物理设备的标准（网线、接口、线路、电路等），及传输信号的一些特性，从而统一计算机网络硬件设备和传输媒体的标准，其传输数据单位是bit（比特），也就是0和1；</p>
<h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p><strong>简介：</strong>物理层的传输媒介分为两类，导向传输媒体和非导向传输媒体；<br><strong>1，导向传输媒体：</strong>指在传输过程中，电磁波沿着固定媒体（铜线或光钎）传播<br><strong><em>双绞线：</em></strong>最古老也是最常用的传输媒介，最为便宜、主要是使用两根绝缘的铜导线并排放在一起，例如常见的电话系统</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p71.png" alt=""></p>
<p><strong>2，同轴电缆：</strong>由内导体铜质芯线、绝缘层、网状编制的外导体屏蔽层以及保护塑料外层所组成，<br><img src="http://devfqh.com/images/ComputerBase/CBase_p72.png" alt=""></p>
<p><strong>3，光缆：</strong>即光钎通信技术，随着计算机的发展，现已大量采用光钎作为传输媒体，其优点主要在于技术先进、快速、便宜等</p>
<p><strong>2，非导向传输媒体：</strong>在某些场合，例如高山、岛屿中，无法大量的开设电缆，因此就需要无线传输来完成，例如无线电波、卫星传输</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><strong>简介：</strong>通信技术中最基本的概念，使得多个主机进行通信时，可共享一个信道，主要操作是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，发送端使用一个复用器，使得多个主机可共享一条信道；</div><div class="line">2，接收端再使用分发器，将合起来传输的信息分别送到对于的目标中；</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p73.png" alt=""> </p>
<p><strong>常见的复用方式有：</strong>频分复用、时分复用、波分复用、统计分时复用，较为复杂不再详细讨论；</p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p><strong>1，XDSL技术：</strong>通过数字技术对现有的模拟电话用户先进行改造，使其能承载宽带业务，常见的接入类型有</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p74.png" alt="">        </p>
<p><strong>2，光钎同轴混合往（HFC）：</strong>即光钎，通常是结合在有线电视的基础上进行开发的一种居民宽带接入技术，其主要线路采用了光钎，并采用结点体系结构，可靠性强、速度快，但其需要家庭安装一个用户接口盒，和机顶盒，再连接电视；</p>
<p><strong>3，FTTx技术：</strong>即光钎到…，此处的x代表不同的意思，也是一种实现宽带居民接入的方式，较为便宜，适用于大量用户组合使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FTTH（fiber  to  the  home)：从光钎铺设到家庭</div><div class="line">FTTO（fiber  to  the  office）：从光钎到办公室</div><div class="line">FTTD（fiber  to  the  door）：从光钎到门户</div><div class="line">FTTZ（fiber  to  the  zone）：从光钎到小区</div></pre></td></tr></table></figure></p>
<h1 id="TCP-IP-–-数据链路层"><a href="#TCP-IP-–-数据链路层" class="headerlink" title="TCP/IP – 数据链路层"></a>TCP/IP – 数据链路层</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>数据链路层：</strong>主要作用是将网络层提交过来的数据，打包成帧（frame），再发送到链路上，最终到达目的主机；<br><strong>链路：</strong>即从一个结点到相邻结点的一段物理线路，而中间没有任何其它的交换结点，两台主机之间的通信路径往往要经过很多段链路；</p>
<p><strong>对于数据链路层使用的信道主要有两种：</strong></p>
<p><strong>点对点：</strong>通过一对一的点对点通信方式<br><strong>广播信道：</strong>即一对多的广播通信方式，由于连接主机过多，其过程也较于复杂；</p>
<h2 id="使用点对点信道的数据链路层："><a href="#使用点对点信道的数据链路层：" class="headerlink" title="使用点对点信道的数据链路层："></a>使用点对点信道的数据链路层：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">结点A的数据链路层  ---&gt;  将网络层提交数据封装成帧  ----&gt;  交给物理层</div><div class="line">结点B的物理层  ----&gt; 提交到结点B的数据链路层  -----&gt; 结点B的网络层</div></pre></td></tr></table></figure>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p75.png" alt="">              </p>
<p><strong>数据链路层的三个基本问题：</strong><br><strong>1，封装成帧：</strong>即将网络层交下来的数据的前后分别添加首部和尾部，即可构成一个帧，物理层通过首部和尾部的标记，即可即系成比特流传输</p>
<p><strong>2，透明传输：</strong>由于帧的开始和结束标记是使用专门指明的控制字符，可能会与传输数据发送冲突，因此需要处理传输数据的特殊字符，例如在发送端和接受端，分别使用转义字符来填充；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p76.png" alt="">        </p>
<p><strong>3，错误检测：</strong>即需检测数据帧丢失的问题</p>
<p><strong>点对点协议PPP（point  to  point  protocol）：</strong>数据链路层协议，以可靠的方式，在链路上的结点与结点之间的数据传输，采用全双工操作，并按照顺序传递数据包，设计的目的是用于通过拨号或专线方式建立点对点连接发送数据，使其成为主机、网桥、路由器之间简单的连接方案</p>
<p><strong>特点： </strong><br>PPP协议是一种点——点串行通信协议。PPP具有处理错误检测、支持多个协议、允许在连接时刻协商IP地址、允许身份认证等功能，还有其他。PPP提供了3类功能：成帧；链路控制协议LCP；网络控制协议NCP。PPP是面向字符类型的协议。</p>
<p><strong>PPP协议的帧格式:</strong></p>
<p>标志字段    地址字段    控制字段    协议    信息部 分    FCS    标志字段</p>
<p><strong>主要组成：</strong><br><strong>封装：</strong>一种封装多协议数据报的方法。PPP 封装提供了不同网络层协议同时在同一链路传输的多路复用技术。PPP 封装精心设计，能保持对大多数常用硬件的兼容性，克服了SLIP不足之处的一种多用途、点到点协议，它提供的WAN数据链接封装服务类似于LAN所提供的封闭服务。所以，PPP不仅仅提供帧定界，而且提供协议标识和位级完整性检查服务。<br><strong>链路控制协议：</strong>一种扩展链路控制协议，用于建立、配置、测试和管理数据链路连接。<br><strong>网络控制协议：</strong>协商该链路上所传输的数据包格式与类型，建立、配置不同的网络层协议</p>
<h2 id="使用广播信道的数据链路层："><a href="#使用广播信道的数据链路层：" class="headerlink" title="使用广播信道的数据链路层："></a>使用广播信道的数据链路层：</h2><p>简介：主要用于一对多的通信，常见的局域网就是用了广播信道；<br>以太网：即Xerox公司开发的局域网规范，是当今局域网采用的通信标准；</p>
<p><strong>局域网的数据链路层：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，具有广播功能，局域网上的主机可共享连接在局域网上的各种硬件和软件资源；</div><div class="line">2，便于系统的扩展和逐渐演变</div><div class="line">3，可靠性高，具有较高的数据传输率，较低的延迟，较小的误差等</div></pre></td></tr></table></figure></p>
<p>计算机与外界局域网的连接是通过通信适配器，即一块网卡来实现的；</p>
<p><strong>常见的传输媒体：</strong>早期使用双绞线，后期采用集线器，及光纤等方式</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p77.png" alt="">      </p>
<p>在局域网中，硬件地址又称物理地址或MAC地址（因为存储在MAC帧中）；</p>
<p><strong>扩展的以太网：</strong>以太网之间主机的距离不能太远，因此为了将以太网的范围扩展，需要一些特殊手段<br><strong>在物理层扩展以太网：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，最早期可通过转发器来实现，但其传输时会使信号削弱</div><div class="line">2，通过光纤和光纤调节器，在主机和集线器之间完成信号</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p78.png" alt=""><br><img src="http://devfqh.com/images/ComputerBase/CBase_p79.png" alt="">                  </p>
<p><strong>在数据链路层扩展以太网：</strong>通过网桥来实现，其好处在于    </p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p80.png" alt="">    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，过滤通信量，增大吞吐量：使得个网段成为隔离开的碰撞域</div><div class="line">2，扩大物理范围：也就增大了以太网上连接主机的最大数目</div><div class="line">3，提高可靠性，当网络出现故障时，只会影响到个别网段</div><div class="line">4，可互连不同物理层，不同MAC子层，不同速率（10Mb/s、100Mb/s等）</div></pre></td></tr></table></figure>
<p><strong>常见的网桥有：</strong>透明网桥、源路由网桥、多网桥接口（以太网交换机）<br><strong>高速以太网：</strong>即速率超过100MB/S的以太网，例如吉比特以太网、10吉比特以太网、100BASE-T以太网等类型；</p>
<h1 id="TCP-IP-–-网络层"><a href="#TCP-IP-–-网络层" class="headerlink" title="TCP/IP – 网络层"></a>TCP/IP – 网络层</h1><p><strong>网际协议IP：</strong>是TCP/IP体系中两个最重要的协议之一，也是最重要的因特网标准协议之一，与其配套的还有四个协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">地址解析协议ARP（Address  Resolution Protocol）</div><div class="line">逆地址解析协议RARP（Reverse Address Resolution Protocol）</div><div class="line">网际控制报文协议ICMP（Internet Control  Message Protocol）</div><div class="line">网际组管理协议IGMP（Internet Group Management Protocol）</div></pre></td></tr></table></figure>
<p><strong>网际协议IP及其配套协议：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p81.png" alt=""></p>
<p><strong>在网络互联的过程中，通常会使用一些中间设备，例如：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，物理层 ----&gt;  转发器</div><div class="line">2，数据链路层  ---&gt; 网桥或桥接器</div><div class="line">3，网络层  ----&gt;  路由器</div><div class="line">4，网络层以上使用的中间设备叫做网关（gateway）</div></pre></td></tr></table></figure></p>
<p><strong>IP地址：</strong>用于为因特网上的每一台主机（或路由器）分配一个唯一的32标识符。每个IP地址都由网络号和主机号两部分组成； </p>
<p><strong>IP地址和硬件地址的不同：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">硬件地址：是物理层和数据链路层使用的地址</div><div class="line">IP地址：是网络层和以上各层使用的地址，是逻辑地址，是通过软件实现的；</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p82.png" alt="">         </p>
<p>如图三个局域网，使用两个路由器R1、R2互连，如果主机H要和主机H2进行通信；则传输的过程为H1 –&gt; R1 —&gt; R2 —&gt; H2；需通过两次转发</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p83.png" alt=""></p>
<p><strong>ARP（地址解析协议）：</strong>根据IP地址，找出其对于的物理地址，在主机内部会有一个IP地址和物理地址的映射表；<br><strong>RARP（逆地址解析协议）：</strong>即根据物理地址，找出其对于的IP地址</p>
<p><strong>使用IP地址通信，而不使用硬件地址解析通信的原因：</strong>由于全世界存在着各式各样的网络，其使用不同的硬件地址，如果要使这些异构网络能够互相通信，就必须使用非常复杂的硬件地址转换工作，如果由用户或用户主机来完成这项工作几乎是不可能的，因此就通过统一的IP地址来解决此复杂的问题；</p>
<p><strong>IP数据报的格式：</strong>一个完整的IP数据报由两部分组成，首部和数据部分，主要字段如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">版本：占4位，即IP协议的版本，通信双方使用的IP协议版本必须一致</div><div class="line">首部长度：占4位，可表示的最大十进制数是15</div><div class="line">区分服务：占8位，用于获取更好的服务</div><div class="line">总长度：指首部和数据部分的长度，单位为字节‘</div><div class="line">标识、 标志、片偏移：</div><div class="line">生存空间：表明数据包在网络中的寿命</div><div class="line">协议：指出此数据报携带的数据时采用何种协议，以便使目的地的IP层知道，应将数据部分上交到那个处理过程</div><div class="line">首部检验和：只检验书包的首部，不包含数据部分</div><div class="line">源地址、目标地址</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p84.png" alt=""></p>
<p><strong>分组转发：</strong>即两台不同的主机，在通信的过程中肯定会经过若干个路由器，那么就需要在这些路由器进行对不同的网络进行分组转发；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p85.png" alt=""></p>
<p><strong>划分子网：</strong>为提高IP地址空间利用率，减少路由表消耗，提高路由器性能，可将所属的物理网络分为若干个子网，其IP地址格式（网络号，子网号，主机号）<br>凡是从其它网络发送给本单位某个主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络的路由器，但此路由器在收到IP数据报后，再按目的地网络号和子网号找到目的子网，再把IP数据报交付给目的主机；</p>
<p><strong>子网掩网：</strong>是一个网络或一个子网的重要属性，通过其来找到目标子网主机；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p86.png" alt="">    </p>
<p><strong>使用子网时分组的转发：</strong>则包含了三部分，目的网络弟子、子网掩码、下一跳地址</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p87.png" alt="">     </p>
<p><strong>网络控制报文协议ICMP：</strong>为了更有效的转发IP数据报和提高交付成功的几率，在网际层使用了ICMP协议，主要用于ICM P差错报告和ICMP询问报文；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p88.png" alt="">        </p>
<h1 id="TCP-IP-–-传输层"><a href="#TCP-IP-–-传输层" class="headerlink" title="TCP/IP – 传输层"></a>TCP/IP – 传输层</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>传输层向上面的应用层提供通信服务，属于面向通信部分的最高层，也是用户功能中的最低层；</p>
<p><strong>IP协议：</strong>提供主机与主机之间的通信，只能将分组数据传输到目的主机，但是无法交付到指定的进程中<br><strong>传输层协议：</strong>提供主机中进程与进程之间，端到端的通信，还需进行差错检查、拥塞控制、流量控制、复用、分用等功能；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p89.png" alt=""><br><img src="http://devfqh.com/images/ComputerBase/CBase_p90.png" alt=""> </p>
<p><strong>传输层的端口：</strong>用于区分主机上的应用程序，可分为服务端、客户端两类<br><strong>1，服务器端口：</strong>有分为两类（系统端口号和登记端口号）<br><code>1.1 系统端口号，已经由系统指派给了TCP/IP的一些重要程序，例如</code><br><img src="http://devfqh.com/images/ComputerBase/CBase_p91.png" alt=""><br><code>1.2  登记端口号：数值为1024 ~ 49151，没有熟知端口号的应用程序使用</code><br><strong>2，客户端端口：</strong>数值为49152~65535，是客户端连接时，进程自动选择使用的；</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><strong>UDP（User Datagram Protocol）用户数据报协议：</strong>主要在IP协议的数据部分上，增加了复用、分用、差错检查的功能，主要特点：</p>
<p><strong>1，面向无连接、速度快：</strong>即发送数据前不需要建立连接，结束时也不需要释放连接<br><strong>2，不可靠：</strong>UDP尽最大努力交付，但不保证一定交付到对应主机的进程中<br><strong>3，面向报文（数据包）：</strong>数据包过长则会造成IP层的分片传输，造成丢包情况；  过短，则会造成IP首部大于数据包部分，也会影响IP层的效率；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发送方：应用层提交下的数据，UDP直接添加首部后，交给IP层； </div><div class="line">接收方：IP层直接去除首部后，交给上层传输层，再到应用层的进程</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p92.png" alt=""></p>
<p><strong>4，没有拥塞控制：</strong>因此网络的阻塞不会造成源主机的发送速度降低，适用于处理视频会议、图像、音乐等实时传输的场合，因为即使传输过程中丢失了部分数据，用户也不会察觉图像、音乐中瞬小的微差错误；</p>
<p><strong>UDP首部格式：</strong>分为首部和数据两部分，首部组成主要由四个字段组成；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，源端口：主要在对方回信时使用，不需要可为0</div><div class="line">2，目的端口：即到达终点目的地进程的端口</div><div class="line">3，长度：数据报的总长度</div><div class="line">4，校验和：检测UDP在用户数据报的传输中是否有错误，有错就丢弃</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p93.png" alt=""></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>TCP（Transmission Control Protocol）传输控制协议：</strong>较为复杂，其主要特点如下<br><strong>1，面向连接、速度略低：</strong>即通信过程中，需要建立连接、确认连接、释放连接；（类似于打电话，需要拨号、进行通话、之后再挂断）<br><strong>2，可靠：</strong>TCP提供可靠交付，也就是通过TCP传递的数据，无差错、不丢失、不重复、并按序到达目标主机的进程中；<br><strong>3，面向字节流：</strong>TCP将应用程序提交下的数据看做是一连串的字节流，接收方接收字节流后，需将其还原成有意义的应用层数据</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p94.png" alt=""></p>
<p><strong>4，采用全双工通信：</strong>即允许通信的双方的进程，在任何使用都能进行发送、接收数据，内部有缓存机制；</p>
<p><strong>TCP的连接实现：</strong>通常通过Socket接口（通信套接字）来实现，每个Socket都包含了一个IP地址和端口，用于完成主机中进程与进程的通信；<br><strong>Socket：</strong>作为传输层的TCP通信实现接口标准，通常指在网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端就称为一个socket，包含了IP和端口；</p>
<p><strong>可靠传输的工作原理：</strong>主要是发送端和接收端每次通信时，通过三次握手，使其同步，由来保证数据的可靠传输<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，客户端向服务端发送syn（syn = j）数据包后，等待服务器处理</div><div class="line">2，服务器收到syn数据包后，进行确认（ack = j + 1），并发送响应数据（syn = k）给客户端</div><div class="line">3，客户端收到服务器的响应数据后，向服务器发送确认包（ack = k + 1）；此时通信结束；</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p95.png" alt=""></p>
<p><strong>超时重传：</strong>即当传输的数据包超时，会进行重新传递，需再次建立连接、握手；</p>
<p><strong>TCP报文段的首部格式：</strong>同样分为首部和数据两部分，虽然TCP面向字节流，但其传输的数据单位却是数据段；其首部格式如下</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p96.png" alt=""></p>
<pre><code>1，源端口和目的端口：占2个字节，分别代表连接的两个进程
2，序号：即报文数据段的序号
3，确认号：占4字节，代表需要收到对方下一个报文段的第一个数据字节序
4，数据偏移：占4位，指出TCP报文段的数据起始处，距离TCP报文段的起时处有多远
5，保留：占6位，日后保留用
6，紧急（URG）：当URG = 1时，代表紧急指针字段有效，其报告系统此报文段中有紧急数据，应尽快传送，提高优先级，而不是按原先的排队顺序传送
7，确认（ACK）：当ACK = 1，确认字段才有效； ACK = 0，则无效；TCP规定，在建立连接后，所有传送的报文段都必须将ACK置1
8，推送：当两个进程进行交互式的通信时，有时候在一端的应用进程希望在键入一个命令后就能立即得到对方的响应，这个时候TCP就可以使用推送的方式创建一个报文段发送出去；
9，复位（RST）：当RST = 1时候，表示TCP连接中出现严重错误（系统奔溃、内存溢出、断电等），必须释放连接，然后再重新建立传输连接；
10，同步（SYN）：在建立连接时，用于同步序号，以此来保证可靠传输，当SYN = 1，ACK = 0时，表明这是一个请求报文段；
11,，终止（FIN）：用于释放一个连接，当FIN = 1时，说明此报文段的发送端的数据已发送完毕，并要求释放运输里阿杰
12，窗口：占2个字节，指的是发送本报文段一方的接收窗口
13，校验和：
14，紧急指针：占2字节，支出本报文段中紧急数据所占的字节
15，选项：
</code></pre><p><strong>流量控制：</strong>即控制传输数据的速率不要太快，要让接收方来得及接收；<br><strong>拥塞控制：</strong>传输层向网络传输数据时，下层网络可能会发生堵塞，这可能会导致丢失数据包，如果传输层检测到网络上有拥塞，就会暂缓发送，或丢弃数据包<br><strong>差错控制：</strong>在消息传输过程中，可能会被损坏、丢失、重复或乱序，为了保证数据被目的传输层正确接收，因此需要检查数据包是否正确；</p>
<h1 id="TCP-IP-–-应用层"><a href="#TCP-IP-–-应用层" class="headerlink" title="TCP/IP – 应用层"></a>TCP/IP – 应用层</h1><p><strong>应用层：</strong>TCP/IP的最顶层，是用户和网络的接口，主要是面向用户的终端的应用，其每一个协议，都是为了解决用户的某一类问题，而问题通常是由位与不同主机的多个应用进程之间的通信来完成的，应用层的许多协议都是基于客户/服务器模式；</p>
<p><strong>域名解析系统（DNS）：</strong>主要用于将主机名称转换成对应的IP地址，域名的组成如下</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p97.png" alt="">   </p>
<p><strong>FTP（File  Transfer  Protocol）：</strong>文件传输协议，基于TCP可靠协议，主要用于传输文件，允许客户指明文件的类型和格式，并允许文件具有存取权限，协议，直到1995年，www的通信量才首次超过FTP；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p98.png" alt="">  </p>
<p><strong>NFS：</strong>与FTP不同，其允许应用远程打开一个文件，并运行其进行读写，这样既可使得用户只复制大文件中的一小部分</p>
<p><strong>TELNET（远程终端协议）：</strong>允许用户进行远程登录到另外一台主机上</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p99.png" alt="">     </p>
<p><strong>imap、smtp、pop：</strong>邮件发送、接收协议等</p>
<p><strong>mime：</strong>多用途因特网邮件扩充协议，严格来说不是一个电子协议，其主要定义了各种文件类型在互联网上，应该用何种方式去打开；</p>
<p><strong>万维网（www）：</strong>以客户/服务器的方式存在，将信息、资源、数据分布在整个因特网上，并通过URL进行标识访问；</p>
<p><strong>http：</strong>超文本传输协议，主要用于万维网中，定义了客户端和web服务器交互的数据格式，主要用于存取web服务器中的数据，以纯文本方式传输文本、音频、视频等信息，以请求 -&gt; 响应的方式</p>
<h1 id="因特网上的音频-视频服务"><a href="#因特网上的音频-视频服务" class="headerlink" title="因特网上的音频/视频服务"></a>因特网上的音频/视频服务</h1><p><strong>多媒体信息在互联网上的传输：</strong>由于含有音频、视频、图像的文件通常较为庞大，因此需要使用特殊的方式进行处理，传输；</p>
<p><strong>目前因特网提供的音频/视频服务可大致分为三类：</strong><br><strong>1，流式存储音频/视频：</strong>即需要将已压缩好的多媒体文件存放在服务器上，用户需下载完毕后，再进行播放；<br><strong>2，流式实况音频/视频：</strong>适用于无线电台、实况直播，其方式是边录制边发送，较为复杂，且成本高，因此不够普及<br><strong>3，交互式音频/视频（流媒体）：</strong>最流行的方式，即通过边下载边播放的方式来提供多媒体服务；</p>
<p><strong>流媒体服务器：</strong>通常会基于UDP来传输，因为对于音频、视频等多媒体资源而言，强调的是传输的速度，即使出现了微小的数据丢失，造成音频不准、或视频部分帧不清晰，用户也不会察觉这些细节；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p100.png" alt=""> </p>
<p><strong>实时传输协议（RTP）：</strong>为实时应用提供端到端的运输，但不提供任何服务质量的保障，发送的多媒体数据块在经过压缩编码处理后，先送给RTP封装成RTP分组（报文），再传入传输层的UDO用户数据报，然后再向下传递给下级的IP层；</p>
<p><strong>实时传输控制协议（RTCP）：</strong>与RTP配合使用，主要负责服务质量的监控、反馈、媒体间的同步，以及多播组中成员的标志等等…</p>
<h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><p><strong>计算机网络面临的主要安全威胁：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，截获：攻击者从网络上窃听他人的通信内容</div><div class="line">2，中断：攻击者由于中断他人在网络上的通信</div><div class="line">3，篡改：攻击者故意篡改用户在网络上传递的报文</div><div class="line">4，伪造：攻击者伪造用户信息，在网络上传输</div></pre></td></tr></table></figure></p>
<p><strong>可分为两大类，被动攻击（截获）和主动攻击（中断、篡改、伪造）：</strong></p>
<p><strong>因特网使用的安全协议：</strong>不同层使用的安全协议不同，且针对于不同场景使用的安全协议也不同；</p>
<p><strong>基本的加解密算法：</strong>虽然加密算法很多，但最基本的有两种，其它算法都是由此演变而来的；<br><strong>1，易位法：</strong>通过重新排列明文中各个字符的位置来形成密文，易位时，先设计一个密钥，对它对明文进行易位，并形成密文；解密时工具密钥再排序</p>
<p><strong>2，置换法：</strong>将明文中的字母按英文字母顺序，往后移动位生成新的替代字母，例如house就变成了hrxvh</p>
<p><strong>对称加密：</strong>即加密和解密使用的是同一个密钥（key），例如常见的DES，但其缺点在于需要传递密钥给客户端，此过程可能会被拦截，那么加密和解密就同样的密钥，则出错；</p>
<p><strong>非对称加密：</strong>即提供了两个密钥（key），一个公钥（public key），一个私有钥（private key），私钥不能外泄，而公钥可以外泄；例如向银行请求一个公钥，通过公钥加密后，那么只有私钥的持有人，银行才能对消息进行解密；与对称加密不同的时，银行不需要将私要通过网络发出去，因此安全性大大提高，目前非对称加密算法是RAS算法；<br>其它方式还有审计、签名生成等方式；</p>
<p><strong>防火墙：</strong>一种特殊的路由器，安装在一个网点和网络的其余部分，目的是为了访问控制策略，通常在防火墙内的网络称为可信网络，防火墙外面的网络称为”不可信网络“</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p101.png" alt="">             </p>
<p><strong>防火墙技术可大致分为两类：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，网络级防火墙：主要用来防止整个网络出现外来非法的入侵，</div><div class="line">2，应用级防火墙：从应用程序来进行访问控制；</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -计算机基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2,操作系统原理]]></title>
      <url>/2015/05/13/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>操作系统：</strong>简称OS，管理计算机硬件和软件资源的计算机程序，是最基本的系统软件，任何其它软件都必须在操作系统的支持下运行；<br>通常认为操作系是管理系统资源、控制程序执行、改善人机界面、提供各种服务、合理组织计算机工作流程，并为用户提供良好运行环境的系统软件；    </p>
<p><strong>计算机系统的层次结构：</strong>由下图可看出，操作系统是计算机最基本的系统软件，位与硬件之上层</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p32.png" alt="">      </p>
<p><strong>硬件层：</strong>即提供了最基本的硬件，如处理器、寄存器、存储器、及各种I/O设备<br><strong>操作系统层：</strong>最靠近硬件的软件，是最底层、最基本的系统软件，也是上层其它软件运行的基础<br><strong>系统程序层：</strong>直接建立在操作系统上，可使用操作系统提供的扩展指令集，用户接口等完成一些系统功能的调用<br><strong>应用层：</strong>针对用户解决不同的问题的应用</p>
<p><strong>操作系统的主要特性：</strong><br><strong>1，并发性：</strong>多任务系统，应调度CPU，使其应具有同时处理和调度多个程序的能力，合理利用系统资源<br><strong>2，共享性：</strong>指操作系统中的资源，应该可被多个并发执行的进程共同使用，需注意同时访问和互斥访问<br><strong>3，异步性：</strong>即随机性，在多个进程并发执行下，由于资源有限，多数情况下，进程的执行不是一次到底，而是可能会被暂停，例如一个进程在CPU上运行一段时间后，可能会被暂停，CPU转让给另外一个进程执行； 这些执行的时间、速度都是不可预知的，因此说进程时异步执行的；但异步性给系统带来了潜在的危险，有可能导致进程产生于时间有关的错误，但只要运行环境相同，操作系统必须保证多次运行进程都能获得完全相同的结果；<br><strong>4，虚拟性：</strong>操作系统中的一种管理技术，是将物理上的一个实体变成逻辑上的多个对应物，采用虚拟化技术目的是为用户提供高效率的操作环境，例如在多进程中，CPU可以只有一个，每次只能执行一个进程，使用多进程和分时CPU技术最大限度达到多任务处理的最高效率；</p>
<p><strong>并发：</strong>实际上是一个物理CPU，在多个进程之间多路复用，即快速切换，以达到多任务处理的目的<br><strong>并行：</strong>多个CPU同时允许多个程序，真正达到多任务处理</p>
<p><strong>多道程序设计系统：</strong>不一定有多个CPU支持，通过CPU调度进程，快速切换，达到多任务处理的目的<br><strong>多重任务系统：</strong>配置了多个CPU，每个CPU负责运行一个进程，真正达到多任务处理；</p>
<p><strong>操作系统的几种类型：</strong><br> <strong>批处理操作系统：</strong>将要计算的问题编程程序，连同数据说明书一起交给操作系统，通过操作用输入到计算机中，完成计算后，由操作员将结果返回给用户；<br><strong> 分时系统：</strong>即可在不同时段，执行多道程序，同样为单任务<br><strong>个人系统（微机系统）：</strong>个人计算机产生后，例如dos、linux、mac，是个人用户也可使用操作系统<br><strong>并行系统：</strong>在一台计算机中安装多个cpu，完成多任务并行处理<br><strong>分布式系统：</strong>随着网络互连的发展，资源/数据可以是分布到远隔千里的多台计算机的，例如一个程序在一台机器上执行一部分，在另外一台机器上执行一部分；<br><strong>实时系统：</strong>指外界事件或数据发送变化时，操作系统能够及时接收并快速响应处理，主要用于监控、军事控制系统，需要实时监控、响应，与通用系统不同<br><strong>网络操作系统：</strong>通过通信设施将地理上分散的多个计算机系统互连起来的系统，windows、unix、linux都算术；<br><strong>嵌入式操作系统：</strong>例如android、ios，主要用于移动设备</p>
<h3 id="操作系统提供的服务和用户"><a href="#操作系统提供的服务和用户" class="headerlink" title="操作系统提供的服务和用户"></a>操作系统提供的服务和用户</h3><p><strong>操作系统提供的基本服务：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1，用户和计算机硬件之间的接口（分为命令行CLI、图形界面GUI等方式）</div><div class="line">2，为用户提供虚拟计算机：即在一台物理机器上，划分多个逻辑机器，再在逻辑机上安装多个操作系统，即虚拟化技术</div><div class="line">3，系统资源的管理者、分配者</div><div class="line">4，存储管理：管理存储器资源，为多道程序提供有力的保障</div><div class="line">5，文件管理：管理各种文件的新建、修改、删除等，时间文件的共享、目录管理、存取空间管理等</div><div class="line">6，设备管理：管理各种外部设备，如I/O设备</div><div class="line">7，网络通信：通常包括网上资源管理、数据通信管理、网络功能等</div></pre></td></tr></table></figure></p>
<p><strong>操作系统提供的用户接口：</strong>用户可通过接口来调用操作系统提供的服务和功能，分为程序接口和系统调用<br><strong>系统接口：</strong>提供了访问系统资源，调用操作系统功能服务的唯一途径，而不必了解操作系统内部结构和硬件细节，例如c、java中的IO操作就是调用操作系统来完成的；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p33.png" alt=""> </p>
<p><strong>程序接口：</strong>即应用程序之间，提供的服务接口，通常不涉及系统资源的调用</p>
<p><strong>系统调用和过程（函数）调用的区别：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，调用形式不同：过程（函数）调用一般调用指令，其转向地址是不变的，包含在跳转语句中； 系统调用，不包含处理程序入口 ，而仅仅提供功能号，按功能号调用；</div><div class="line">2，被调用代码位置不同：过程是静态调用，即会包含被调用者的代码，通过编译链结成为目标代码的一部分；而系统调用是动态调用，系统调用的处理代码在操作系统中，与应用程序无关</div><div class="line">3，提供方式不同：过程往往由编译系统提供，而系统调用一定由操作系统，一旦操作系统设计好，则永远不可变</div></pre></td></tr></table></figure></p>
<p><strong>linux的系统调用：</strong>最多提供了190个系统调用，每个系统调用由两部分组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，核心函数：系统功能的核心代码，作为操作系统的核心驻留在内存中，是一种共享代码</div><div class="line">2，接口函数：即提供给应用程序的API，以库函数的形式存储在Linux的lib中，该库存放了所有系统调用的接口函数的目标、入口，通常由c、汇编编写；</div></pre></td></tr></table></figure></p>
<h3 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h3><h4 id="操作系统的构件："><a href="#操作系统的构件：" class="headerlink" title="操作系统的构件："></a>操作系统的构件：</h4><p><strong>1，内核：</strong>操作系统的最核心，负责对硬件处理器等资源进行管理，为进程的执行提供良好的运行环境录入员<br><strong>2，进程：</strong>是并发程序设计的一个工具，通常是指执行中的一个程序；<br><strong>3，线程：</strong>早期进程是操作系统进行资源分配和调度的基本单位，但其开销过大，线程作为一个进程中的控制流，来减少系统运行进程的时空开销，一个进程可包含多个可并发执行的控制流；由此线程又称轻量级进程；<br><strong>4，管程：</strong>管理共享资源的程序，是一种同步机制，用于在多任务处理时候，同步以保证数据的正确性；<br><strong>5，类程：</strong>管理私有资源，通过类程可完成对操作系统私有资源的调用；</p>
<p><strong>从操作系统的体系结构区分可分为：</strong>整体式、层次上、虚拟机式、客户/服务器、微内核结构<br><strong>1，整体式结构：</strong>即模块作为操作系统的基本单位，按照功能将系统分解为若干个模块来使用<br><strong>2，层次结构：</strong>把操作系统分为内核和若干模块（或进程），并按功能的调用次序排列成若干层次，各层之间只能是单向依赖或是单向调用关系，即低层为高层服务，高层可以调用低层的功能；<br><strong>3，虚拟机结构操作系统：</strong>即在一台物理计算机资源通过虚拟化技术，安装多个操作系统<br><strong>4，客户/服务器结构：</strong>随着网络技术和数据库的发展，客户/服务器逐渐成为主流操作系统</p>
<p><strong>微内核的设计：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，基本存储管理</div><div class="line">2，进程间通信：通过指定端口，来完成进程间通信，以消息的形式</div><div class="line">3，I/O和中断管理</div></pre></td></tr></table></figure></p>
<p><strong>操作系统功能的实现模型：</strong><br><strong>1，非进程内核模型：</strong>老式的操作系统，即操作系统的功能都不组织成进程来实现。当中断发生时，当前运行进程的上下文现场信息将被保存，并把控制权传递给操作系统内核。操作系统具有自己的内存区和系统堆栈区，用于控制过程调用和返回。</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p35.png" alt=""> </p>
<p><strong> 2，OS功能（函数）在用户进程内执行的模型：</strong>小型机和工作站操作系统（如类unix等），通常采用OS的所有功能（函数）在用户进程内支线的模型，在此种实现模型中，大部分操作系统功能组织成一组例行程序以供用户调用；其包括了进程控制块、用户堆栈、容纳用户程序和数据的地址空间等、还包括操作系统内核的程序、数据、系统对战区；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p34.png" alt="">            </p>
<p><strong>3，OS功能（函数）作为独立进程执行的模型：</strong>OS功能作为独立的进程执行，将操作系统组织成一组系统进程，这些进程又称为服务进程或系统进程；</p>
<h3 id="实例探究：windows2000-xp客户-服务器架构："><a href="#实例探究：windows2000-xp客户-服务器架构：" class="headerlink" title="实例探究：windows2000/xp客户/服务器架构："></a>实例探究：windows2000/xp客户/服务器架构：</h3><p>windows2000/xp 客户/服务器架构：采用基于对象的技术，属于客户/服务器系统结构；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p36.png" alt=""> </p>
<p><strong>硬件抽象层：</strong>即最底层的硬件，如系统总线、I/O接口、处理器、主存等；<br><strong>设备驱动程序：</strong>是可加载的核心动态模块，是I/O系统和硬件之间的接口；<br><strong>内核：</strong>是操作系统最基本的操作，包含进程调度、线程调度、中断处理、等核心功能</p>
<p><strong>常见操作系统：</strong>DOS、windows、unix、linux、mac os、Mach、Netware、Minix、android、ios</p>
<h2 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p><strong>处理器：</strong>现代计算机中，将控制器、运算器、寄存器集成到了一块芯片上，通常称为CPU；</p>
<p><strong>目前计算机操作系统的处理器管理分为四类：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SISD（单指令、单数据流）：表示计算机只有一个控制单元、一个算术逻辑单元、一个内存单元，只能同时处理一条指令</div><div class="line">SIMD（单指令流、多数据流）：单条指令表示计算机只有一个控制单元、多个算术逻辑单元、一个内存单元</div><div class="line">MISD（多指令流、单数据流）：</div><div class="line">MIMD（多指令流、多数据流）：多个控制单元、多个算术逻辑单元、多个内存单元，可同时处理多条指令</div></pre></td></tr></table></figure></p>
<p><strong>寄存器：</strong>通常包含在计算机的处理器，是最顶级存储，容量小，但速度最快；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">通用寄存器：可由程序设计者使用，并指定功能，如存放操作数、寻址寄存器等</div><div class="line">数据寄存器：较为少用，通常会使用硬盘来存储数据</div><div class="line">指令寄存器：cpu需要从内存中取出指令，并存储到寄存器中，解释并执行</div><div class="line">程序计数器：保存当前正在执行的指令，并存储下一条指令的内存地址</div><div class="line">I/O地址寄存器：用于指定I/O设备</div><div class="line">数据缓冲寄存器：用于处理器和I/O设备交换数据时的缓存机制</div></pre></td></tr></table></figure></p>
<p><strong>特权指令：</strong>只能提供给操作系统的核心程序使用的指令，如启动输入/输出设备、设置时钟、控制终端屏蔽位、清内存、建立存储键、加载 PSWenger<br><strong>非特权指令：</strong>一般用户可执行的指令<br><strong>处理器状态：</strong>即处理器的运行模式，大部分系统将处理器状态划分为管理状态和用户状态；<br><strong>中断技术：</strong>指程序执行过程中，当发生某个事件时，终止CPU上现行程序的运行，并触发该事件的处理程序；现代操作系统通常都具有处理突发事件的能力；</p>
<p><strong>事件源：</strong>引起中断的事件<br><strong>中断装置：</strong>发现中断源头，并启动中断程序的硬件<br><strong>中断源分类：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">强迫性中断：不是运行程序所能控制的，例如机器故障终端、电源故障、主存储器出错、输入/输出设备错误等;</div><div class="line">自愿式中断：程序运行所控制的中断，例如任务调度过程中，</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p37.png" alt="">   </p>
<p><strong>常见中断事件的处理：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，电源故障处理：通常是将处理器中有关寄存器的信息保存，并停止处理器工作，当故障排除后，恢复中断现场，重新启动设备</div><div class="line">2，主存储器故障处理：向系统发出错误信息和出错地址</div><div class="line">3，程序性中断事件处理：通常是停止程序运行，并给予出错信息</div></pre></td></tr></table></figure>
<p><strong>中断的优先级：</strong>即当多个中断事件发生时，计算机会按一定的算法，处理中断事件的先后顺序；<br><strong>中断的屏蔽：</strong>主机可允许或禁止某类中断的响应，例如主机可控制所有的输入/输出设备、外部中断、机器校验中断、以及某些程序中断，对于被中断的操作，有些将被丢弃，有些将被继续执行</p>
<p><strong>实例研究：</strong>windows2000/xp 中断处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">中断：异步的事件，可能会随时发生，与处理器正在执行的内容无关，中断主要由I/O设备、处理器时钟、定时器等；</div><div class="line">异常：同步事件，是某一个特定指令执行的结果，通常是正在运行的程序所抛出的，例如内存访问错误、调试指令等</div></pre></td></tr></table></figure></p>
<p>简单的说，当发生中断时，设备会像操作系统内核发送消息，由系统内核根据中断事件的优先级进行处理；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p38.png" alt="">           </p>
<h3 id="处理器调度-1"><a href="#处理器调度-1" class="headerlink" title="处理器调度"></a>处理器调度</h3><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p><strong>进程调度器：</strong>负责动态将处理器分配给进程，并且负责进程运行期间的各种状态切换，分为三个级别<br><strong>1，高级调度：</strong>即从多道任务（作业）中选出若干个作业，分配必要的资源，并建立与作业相对应的进程，如内存、外部设备等，最后将程序和数据调入内存，等待进程调度程序对其执行调度，并在作业完成后做后续处理操作；<br><strong>2，中级调度：</strong>又称平衡负载调度，根据存储资源量和进程当前状态，来决定主存中的进程对换，主要操作是将一些进程移除主存，使其挂起，不参与低级调度，从而起到短期平滑和调整系统负荷的作用；<br><strong>3，低级调度：</strong>又称进程调度（线程调度、短程调度），根据某种算法决定进程就绪队列中，那一个进程可以获得CPU，并运行；低级调度有两种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">剥夺方式：当一个进程或线程在处理器上执行时，若有一个更高级别的进程或线程产生，则立即暂停当前正在执行的进程，并让出CPU分配给级别更高的进程或线程使用；</div><div class="line">非剥夺方式：一旦某个进程或线程开始在CPU上执行，则不能再让出CPU，除非该进程或线程运行结束，或出现了某些不能执行的阻塞事件；</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p39.png" alt="">             </p>
<p><strong>调度过程要点：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，记录进程的状态</div><div class="line">2，决定某个进程，何时获得处理器，以及占用多长时间</div><div class="line">3，将处理器分配给进程</div><div class="line">4，回收处理器</div></pre></td></tr></table></figure></p>
<p><strong>低级调度的常见算法：</strong></p>
<p><strong>先来先服务算法：</strong>按进程进入就绪队列的先后次序来为进程分配处理器，并运行，最简单实现的算法<br><strong>时间片轮转调度：</strong>即为每个进程分配一个时间片，当次时间片结束后，就强迫该进程让出处理器<br><strong>优先数调度：</strong>为每个进程确定一个优先数，CPU每次选择就绪队列中，优先数最大者运行<br><strong>多级反馈队列调度：</strong>将就绪进程或线程分为多级，系统响应建立多级就绪队列，优先级较高的队列一般分配给较短的时间片，处理器调度每次先从高一级的就绪进队列中选取可占有处理器的进程，同一队列则按先来先服务策略进行排队，</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p40.png" alt="">                 </p>
<p><strong>保证调度算法：</strong>向用户做出明确的性能保证，系统必须跟踪各个进程自创建以来运行了多少CPU，以及时间<br><strong>彩票调度算法：</strong>为进程发放各种系统资源，例如发出100张彩票，某一个进程拥有20张，那么久拥有20%的中奖几率，也获得大约20%的cpu时间；<br><strong>单比率算法：</strong>为每个进程分配一个与事件发生频率成正比的优先数，运行频率越高的进程其优先数越高，调度程序总是选择优先数最高的就绪进程；<br><strong>限期算法：</strong>当一个事件发生时，对应的进程及被加入就绪进程队列，该就绪队列安装截止日期排序<br><strong>最少裕算法：</strong>计算各个进程的富裕时间，即裕度，然后选择裕度最少的进程执行，因为说明时间很紧迫，就绪后应尽快运行</p>
<p><strong>选择调度算法的原则：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1，资源利用率：使得CPU和其它资源的使用率尽可能高，并能够并行工作</div><div class="line">2，响应时间：交互式进程从提交一个请求到接收，响应直接的时间，应该尽可能短</div><div class="line">3，周转时间：即完成作业的时间，尽可能短    </div><div class="line">4，吞吐率：单位时间内处理的作业/任务，尽可能多</div><div class="line">5，公平性：确保每个用户，每个进程获得合理的CPU或资源份额，不会出现死锁、饿死的情况</div></pre></td></tr></table></figure></p>
<p><strong>实时操作系统的特性：</strong>指时间因素非常关键的系统，主要用于军事、监控、航天等，分为硬实时，软实时；前者意味着必须存在满足的时间限制，或者意味偶尔超过时间限制是可以容忍的；<br><strong>实时调度算法：</strong>分为动态实时调度算法，在运行时做出调度决定；静态实时调度算法，在系统启动之前就已经完成所有的调度决策；</p>
<h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h4><p><strong>作业调度器：</strong>负责调度作业后备队列中，并根据该算法，选取作业，并建立与作业相对应的进程，或加入到进程中执行<br><strong>作业和进程的关系：</strong>作业（job）是用户提交给操作系统计算的一个独立任务，而进程是系统进行调度和资源分配的基本单元，代表了程序执行的过程，进程为完成作业任务需向系统申请分配资源，进程在“运行”、“就绪”、”等待“等多个状态的交替中，在CPU中推进，最终完成一组程序的作业；</p>
<p><strong>作业调度算法：</strong><br><strong>1，先来先服务算法（FCFS、first come，first served）：</strong>按作业进入系统的作业队列的先后次序，先进入系统的作业优先被挑选，并分配资源，建立与作业对应的进程；非剥夺式的算法，容易实现，但效率不高，只顾及了作业等候时间，而忽略了作业要求服务时间的长短<br><strong>2，最短作业优先算法（SJF，shortest job forst）：</strong>以进入系统作业后所要求CPU时间长短为标准，总算选取估计时间最短的作业投入运行，也是非剥夺式，缺点在于需要预先知道作业所需的CPU时间，难以估计<br><strong>3，最短剩余时间有限算法（SRTF）：</strong><br><strong>4，优先数算法：</strong>根据确定的优先数来选取作业，每次总是选取优先数最高的作业<br><strong>5，响应比最高者优先算法：</strong>每当调度一个作业运行时，都要计算后备作业队列每个作业的相应比，选择响应比最高者投入运行<br><strong>6，分类调度算法：</strong>将作业分类，以达到操作系统均衡资源和兼顾大小的目的，可按作业计算时间、对内存需求、对设备需求等</p>
<h4 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h4><p><strong>简介：</strong>现主流的计算机系统都会包括多个处理器，其调度的方式也有所不同.<br><strong>多处理器调度设计要点：</strong><br><strong>1，如何把进程分配到对应的处理器上运行：</strong>多个处理器对主存和I/O设备的访问都是相同的，那么所有的处理器可放入一个处理器池（pool）。可采用主从式管理结构（master/slave），即操作系统的核心部分运行在一个特殊的处理器上，而其它处理器则运行用户程序，较为容易实现；也可采用分布式管理结构（peer-to-peer），操作系统核心可在所有处理器上执行，每个处理器也可实现自我调度，此种方式则较为复杂；<br><strong>2，单个处理器上是否支持多道程序设计：</strong><br><strong>3，如何指派进程：</strong></p>
<p><strong>多处理器调度算法：</strong><br><strong>1，负载共享算法：</strong>即进程不分配给某个特定的处理器，由系统来维护一个全局就绪线程队列，当一个处理器空闲时，就选择一个就绪线程占有处理器<br><strong><em>优点：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">将负载均分到所有可用的处理器上，保证处理器效率的提高；</div><div class="line">不需要集中的一个调度程序，一旦某个处理器空闲，操作系统的调度程序即可允许在该处理器上选择下一个运行的线程；</div></pre></td></tr></table></figure></p>
<p><strong><em>缺点：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">就绪线程队列必须被互斥访问，当系统包含很多个处理器，且多个处理器同时挑选进程时，会成为性能的瓶颈；</div><div class="line">被抢占的线程很难在同一个处理器上恢复执行，当处理器带有高速缓存时，</div></pre></td></tr></table></figure></p>
<p><strong>2，群调度算法：</strong>将一组进程在同一时间一次性调度到一组处理器上运行<br><strong><em>优点：</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一次性调度一组处理器，较少调度次数，产生的时空代价</div><div class="line">当紧密的进程同时执行时，同步互斥造成等待的时间将减少，进程的切换相应减少，系统性能也随之提高</div></pre></td></tr></table></figure></p>
<p><strong>3，处理器专派调度算法：</strong>把一个应用指派给一组处理器，一旦应用被调度并执行，它的每一个线程被分配一个处理器，并占用直到这个运行结束；<br><strong>4，动态调度算法：</strong>由操作系统和应用进程共同完成调度，操作系统负责再应用进程之间划分处理器。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p><strong>进程：</strong>即执行中的一个程序，是操作系统进行资源分配和系统调度的最基本单元，每个进程都拥有自己独立的存储空间和运行环境；<br><strong>并发：</strong>实际是一个CPU，在多个进程之间快速切换，来达到多任务处理的目的<br><strong>并行：</strong>多个CPU，分别处理多个进程，真正达到多任务处理；</p>
<p><strong>进程的特性：</strong><br><strong>1，结构性：</strong>进程包含了数据集合和运行于其之上的程序，每个进程通常有四块组成（控制块、程序块、数据块、堆栈）<br><strong>2，共享性：</strong>多个进程可以共享相同的程序、数据等<br><strong>3，独立性：</strong>进程时系统进行资源分配和调度的基本单元，通常进程与进程之间是互相独立的<br><strong>4，制约性：</strong>并发进程之间存在着制约关系，进程在进行的关键点上需要互相等待，以保证程序多次执行结果是一致的；<br><strong>5，并发性：</strong>进程是可并发的执行的，由于资源有限，进程的执行不是一次到底，而是可能会被暂停，例如一个进程在CPU上运行一段时间后，可能会被暂停，CPU转让给另外一个进程执行； </p>
<p><strong>进程的内存映象：</strong>当一个程序被加载到内存进行计算，就构成了进程。操作系统将进程实体和运行环境，称为进程上下文，通常由三个部分组成；<br><strong> 用户级上下文（user level context）：</strong>由用户进程的程序块、用户数据块、用户堆栈组成的进程地址空间<br><strong> 系统级上下文（system level context）：</strong>包含进程的标识信息、现场信息、控制信息、进程环境、即系统堆栈等组成的进程地址空间<br><strong> 寄存器上下文（register context）：</strong>由各类寄存器组成，如程序寄存器、程序计数器、地址寄存器、通用寄存器</p>
<p><strong>操作系统的控制表：</strong>主要分为四类，进程控制表、存储控制表、I/O控制表、文件控制表<br><strong>进程控制表：</strong>用于管理进程及其相关信息<br><strong>存储控制表：</strong>用于管理主存储器、辅存储器信息<br><strong>I/O控制表：</strong>管理计算机系统的I/O设备和通道，主要包括I/O设备和通道是否可用，分配信息，状态，通道传输数据所在存储区<br><strong>文件控制表：</strong>管理文件，主要包括被打开文件信息、状态等<br>.<br><strong>进程控制表简单包括包括：</strong>程序块、数据块、堆栈、进程控制块四部分组成<br><strong>程序块：</strong>即将要被执行的程序，规定了进程执行一次完成的功能，通常是纯代码，作为系统资源被多个进程共享<br><strong>数据块：</strong>即程序运行中包括的数据，例如局部变量、全局变量、常量等存放区；<br><strong>系统/用户堆栈：</strong>每个进程都将捆绑一个堆栈，用于解决程序执行过程中的信息存储和参数传递<br><strong>进程控制块：</strong>描述、记录进程执行的动态变化及有关信息的数据结构，通常包含三类信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">标识信息：唯一标识一个进程，通常由用户外部标识符合系统内部标识符组成，常用的标识信息包括进程标识符号、进程每、用户组名等</div><div class="line">现场信息：保留一个进程在运行时存放在处理器现场的各种信息，而当进程重新恢复时，也要改恢复处理器现场</div><div class="line">控制信息：管理和调度一个进程，常见的控制信息如进程状态、等待事件、等待原因、进程优先级、队列、CPU占用信息、资源分配信息等...</div></pre></td></tr></table></figure></p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p><strong>简介：</strong>中断是激活操作系统的唯一方法，它暂时中止当前运行进程，把处理器切换到操作系统的控制下，当操作系统获得处理器控制权后，它就可以实现进程切换；<br><strong>进程切换的步骤如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1，保存被中断进程的处理器现场</div><div class="line">2，修改被中断进程的有关信息，如进程状态等</div><div class="line">3，将被中断进程加入到有关队列</div><div class="line">4，选择下一个占有处理器的进程运行</div><div class="line">5，修改被选中进程的有关信息</div><div class="line">6，恢复处理器现场</div></pre></td></tr></table></figure></p>
<p><strong>进程控制：</strong>是处理器的另外一个重要工作，负责控制进程的生命周期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1，进程创建：在主进程表中增加一项，并分配内存空间，地址，加入进程队列</div><div class="line">2，阻塞和唤醒：阻塞是指进程让出处理器，去等待一个事件完成；而唤醒是使该进程阻塞的进程，重新恢复运行</div><div class="line">3，挂起和激活：与阻塞和唤醒类似；</div><div class="line">4，终止进程：即停止一个进程的运行</div><div class="line">5，撤销进程：通常是进程正常运行结束、或执行了非法指令、严重的输入/输出故障，等待时间过长等...</div></pre></td></tr></table></figure></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>进程的生命周期：</strong>即一个进程从创建到消亡的整个过程，可分为三态模式、五状模式；</p>
<p><strong>三态模型：</strong></p>
<pre><code>就绪状态：程序已经完整的加载到内存，等待系统调度，分配cpu运行
运行状态：进程在cpu中执行
等待状态：又称阻塞或睡眠状态，指进程不具备运行条件，正在等待某个事件的完成
</code></pre><p><img src="http://devfqh.com/images/ComputerBase/CBase_p41.png" alt=""> </p>
<p><strong>五态模型：</strong></p>
<p><strong>保持状态：</strong>当一个程序被操作性系统选为作业的时候<br><strong>就绪状态：</strong>程序已经完整的加载到内存，等待系统分配cpu运行<br><strong>运行状态：</strong>当在内存中保持这个状态，并被cpu执行<br><strong>等待状态：</strong>又称阻塞或睡眠状态，指进程不具备运行条件，正在等待某个事件的完成，例如等待IO设备操作等<br><strong>终止状态：</strong>即进程运行完毕后，将会成为终止状态，并被回收</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p42.png" alt="">                  </p>
<p><strong>作业（job）：</strong>是用户提交给操作系统的一个独立任务，一个进程可以包含很多个任务，进程在CPU中推进，最终完成一组程序的作业；<br>每个作业都是程序，但并不是所有的程序都是作业；</p>
<p><strong>具有挂起功能的进程生命周期：</strong>即进程在运行过程中，出现了等待事件，则会被挂起，当事件解除后，进程会重新回到运行状态；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p43.png" alt="">     </p>
<p><strong>队列（等待列表）：</strong>当很多进程并发时，操作系统就需使用队列来存放这些信息，以保证顺序的执行，通常操作系统有三个队列，作业队列、就绪队列、I/O队列</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p44.png" alt="">      </p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>简介：</strong>早期操作系统，进程是系统进行资源分配和调度的基本单元，其缺点在于：</p>
<p>1，进程其拥有独立的存储空间和内存地址，时空开销大<br>2，属于单线程结构，只有一个执行控制流，只能同时处理一个请求<br>3，不适于并行计算和分布式并行计算的要求，对于多处理器和分布式计算环境，进程之间大量频繁通信，会大大降低并行度<br>4，不适合客户/服务器计算的要求，因为客户端会同时发送多个请求，而服务端同时只能处理一次</p>
<p><strong>线程：</strong>是进程中的一条执行控制流，负责执行指令代码，是现代操作系统进行资源分配和调度的最小单元；<br><strong>多线程结构：</strong>即一个进程中拥有多个线程（执行控制流），真正的减少程序并发执行的时间、空间开销，其本质开始CPU抢夺式资源，不断的切换进程、线程来达到多任务处理；<br>如果说操作系统引入进程，是为了多个程序能够并发执行，那么操作系统引入线程，则是为了减少程序并发执行时所付出的时间、空间开销；<br><strong>单线程进程（模型）：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p45.png" alt="">     </p>
<p><strong>多线程进程（模型）：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p46.png" alt="">      </p>
<p><strong>线程的生命周期：</strong>与进程类似，可分为三态、五态两种区分方式，就绪、运行、等待、保持、终止；</p>
<h3 id="实例研究-windows2000-xp的进程与线程："><a href="#实例研究-windows2000-xp的进程与线程：" class="headerlink" title="实例研究 - windows2000/xp的进程与线程："></a>实例研究 - windows2000/xp的进程与线程：</h3><p>包含三个层次的执行对象，进程、线程、作业；<br>1，作业、进程、线程是基于对象来实现的<br>2，一个可执行的进程可包含多个线程<br>3，进程或线程两者内部都有同步设施</p>
<p>当用户首次注册时，windows2000/xp会为用户分配一个访问令牌access token，其包含安全标识和进程凭证，此用户建立的每一个进程都均有这个访问令牌的拷贝；系统内核使用访问令牌来验证用户是否安全权限；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p47.png" alt="">  </p>
<p><strong>对象及对象管理器：</strong>windows xp是基于面向对象的系统，其系统资源都是通过对象来表示的，主要定义了两类对象；<br><strong>1，执行体对象：</strong>由执行体的各种组件实现的对象，例如进程、线程、区域、文件、时间、对象目录、端口、终端、关键字、目录对象等<br><strong>2，内核对象：</strong>是由系统内核实现的最原始对象，例如电池对象、内核过程对象、延迟过程调用对象、中断对象、</p>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p><strong>顺序程序设计：</strong>早期程序设计方案，只有当一个操作结束后，才能继续后续的操作；</p>
<p><strong>进程的并发性：</strong>即程序的执行不再是顺序的， 一个程序未执行完，另外一个程序便已开始执行，一组进程的执行在时间上时重叠的；例如两个进程A和B，他们执行的操作为a1、a2、a3、b1、b2、b3，这是顺序执行的，但如果采用并发执行那么其操作将会是交叉随机的，例如a1、b3、b2、a2、a3、b1等情况；</p>
<p><strong>采用并发程序的好处：</strong><br>1，若为单处理器系统，可有效的利用资源，使处理器和I/O设备之间同时工作，充分发挥机器的并行能力<br>2，若为多处理器系统，可让进程在不同处理器上，物理的并行工作，真正达到多任务并行处理</p>
<p><strong>管道（pipe）：</strong>unix和c语言的传统通信机制，也是unix发展最有意义的贡献之一。发送者进程和接受者进程之间通过管道交流信息；<br>1，直接通信方式：直接通过send、receive来实现进程通信，通常是tcp<br>2，简介通信方式：通过一个共享的数据源（信箱），来完成通信，例如udp<br><img src="http://devfqh.com/images/ComputerBase/CBase_p48.png" alt="">         </p>
<p><strong>进程安全：</strong>当资源可被多个进程同时使用，可能会操作数据错误，不安全；，例如购买飞机票问题，假设有两个终端分别运行进程T1、T2，可同时共享数据余票，那么就会出现，同张票可能会被卖出多次的错误；</p>
<p><strong>同步：</strong>操作共享数据通常使用同步来解决，即资源同一时刻只能被一个进程所访问，其它进程需要等待上一个进程释放锁，才可访问；.<br>在大部分操作系统中，文件都是同步的不可共享的：</p>
<p><strong>同步过多造成的问题：</strong><br><strong>死锁：</strong>通常是在同步过多的情况下发送，例如有两个线程A和B，进程A已经占用了file1，并等待file2；而进程B占用了file2，并等待file1；此时就会造成死锁，程序停在这里了，占用资源，死锁的条件<br><img src="http://devfqh.com/images/ComputerBase/CBase_p49.png" alt="">      </p>
<p><strong>饿死：</strong>与死锁相反，发送在操作系统对进程分配资源有太多限制的时候，例如一个操作系统规定一个进程只有在所需的所有资源都为其占用时才能执行；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p50.png" alt="">               </p>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>存储管理：</strong>是操作系统最终要的组成部分，负责管理计算机系统的主存储器，任何程序及数据都必须占用主存空间后才能执行；<br><strong>主存通常包括两部分:</strong><br><strong>系统区：</strong>存放操作系统核心程序，以及标准子程序；<br><strong>用户区：</strong>存放用户的程序和数据，供正在执行的应用程序使用；</p>
<p><strong>主存储器的层次结构：</strong>通常分为寄存器  —&gt;  高速缓存  —-&gt;  主存（内存）  —-&gt;  磁盘   —-&gt;   硬盘 —-&gt; 可移动存储设备等；越往上速度越快，同时价格也越高<br><img src="http://devfqh.com/images/ComputerBase/CBase_p51.png" alt="">     </p>
<h3 id="连续存储空间管理"><a href="#连续存储空间管理" class="headerlink" title="连续存储空间管理"></a>连续存储空间管理</h3><p><strong>连续存储空间管理：</strong><br><strong>单用户连续存储管理：</strong>又称单分区模式，适用于单用户情况，主存储分为系统区和用户区；任何时刻，主存最多只能有一到程序，各个作业的程序只能按次序一个一个装入主存运行；<br><strong>固定分区存储管理：</strong>将进入主存的用户作业划分一块连续存储区域，将作业装入该连续存储区域，若有多个作业装入主存，则可并发执行，是满足多道程序并发设计的最简单存储管理技术；<br><strong>可变分区存储管理：</strong>又称变长分区模式，按作业的大小来划分分区，但划分的时间、大小、位置都是动态的，系统在作业装入主存执行之前并不建立分区，当要装入一个作业时，根据作业需要的主存容量来查看主存中是否有足够空间；</p>
<p><strong>常见可变分区管理的分配算法：</strong><br><strong>1，最先适应（first  fit）分配算法：</strong>每次分配时，总是从未分配区的链表头查找为分配表，直到只找到第一个满足长度要求的空闲区为止<br><strong>2，下次适应（next fit）分配算法：</strong>每次分配时，总是从未分配区上次扫描结束处，顺序查找未分配表或链表，直到只找到第一个满足长度要求的空闲区为止<br><strong>3，最优适应（best fit）分配算法：</strong>扫描整个未分配区表，从空闲去中挑选一个能满足作业要求的最小分区进行分配；<br><strong>4，最坏适应（worst fit）分配算法：</strong>扫描整个未分配区，挑选一个最大空闲去分配给作业使用<br><strong>5，快速适应（quick fit）算法：</strong>为那些经常用到的长度空闲去，设立单独空闲链表，较为复杂….</p>
<h3 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h3><p>采用分区方式管理，每道程序总是要求占用主存的一个或多个连续区域，会导致在主存储中产生许多碎片，且有时为了接纳一个新的作业要移动已在主存的信息，十分不方便，并影响开销；<br><strong>采用分页式管理：</strong>将一个作业存放到若干不相邻的分区中，即可免去移动信息的工作，又可充分利用主存信息，尽量减少主存内的碎片；<br><strong>基本原理：</strong></p>
<p><strong>1，页框：</strong>物理地址分成大小相等的许多区，每个区称为一块<br><strong>2，页面：</strong>逻辑地址分成大小相等的区，区的大小与块的大小相等，每个区称一个页面<br><strong>3，</strong>逻辑地址形式，分为页号和单元号</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p52.png" alt=""></p>
<p><strong>分页式存储空间的分配和去配：</strong>将主存的可分配区按页面大小分成若干块，主存分配以块为单元；最简单的方法通过一张位示图来记录主存分配情况，指出已分配的块和尚未分配的块以及当前有多少空闲块；</p>
<h3 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h3><p><strong>分段式存储管理：</strong>以段为单元进行存储分配，其二维逻辑地址如下;<br>分段式存储管理的实现可基于可变分区存储管理的原理，为作业的每一段分配一个连续的存储空间，但是个个段之间不一定是连续存储的；<br>。。。 看不懂。。。</p>
<h3 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h3><p><strong>简介：</strong>上述的各种存储管理方式，必须为作业分配足够的存储空间，以装入有关作业的全部信息，且作业的大小不可超过主存可用空间；<br>较为复杂，对于应用开发人员，无需深入了解，此处略过。。。<br>但将有关作业的全部信息都装入主存后，作业执行时实际上不是同时使用全部信息的，有些信息甚至运行一遍也不会被使用；<br><strong>虚拟存储器：</strong>即具有层次结构存储器的计算机系统中，采用自动实现部分装入和部分对换功能，即可通过作业提交时，先全部进入辅助存储器，将作业即将允许的一部分进入主存储；为用户提供一个比物理主存容量大得，就好像计算机系统具有一个大容量的主存储器，通常称为虚拟存储器；<br><strong>虚拟存储器概念图：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p53.png" alt=""></p>
<p><strong>请求分页虚拟存储的页表结构：</strong>与分页存储不同，仅仅将当前运行作业和进程进入主存，那么可能会出现某些要执行的页面或资源数据不在主存中，即缺失数据页的情况，因此需要为页表扩充字段，如下，添加驻留标志，指定该页存储数据存储地址；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p54.png" alt="">     </p>
<p><strong>请求分页虚拟存储地址转换：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p55.png" alt="">           </p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="I-O-硬件原理"><a href="#I-O-硬件原理" class="headerlink" title="I/O 硬件原理"></a>I/O 硬件原理</h3><p><strong>简介：</strong>现代计算机系统中配置了大量外围设备，通常分为两类，一类是存储型设备，如u盘、移动硬盘等；一类是I/O设备，负责接受用户请求，并返回计算结果；</p>
<p><strong>I/O系统：</strong>通常指I/O设备及其接口线路、控制部件、通道和管理软件的组合；<br><strong>I/O操作：</strong>指计算机的主存和外围设备的介质之间信息传送操作；</p>
<p><strong>I/O控制方式：</strong>即CPU如何对I/O设备的职能进行合理分工<br><strong>询问方式：</strong>又称程序直接控制方式，即CPU会不断的查询I/O设备的就绪情况，如果已经就绪则开始传送，否则重复询问；每传递一个字节都需修改计数值、内存地址，并再次询问I/O设备状态；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p56.png" alt="">              </p>
<p><strong>中断方式：</strong>首先cpu告知IO设备即将开始传输，但是cpu并不需要不断检测IO设备的状态，当IO设备准备好时，他通知中断CPU，在此过程中CPU还可处理其它的工作，不至于浪费操作；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p57.png" alt=""></p>
<p><strong>直接存储方式：</strong>适用于在高速IO设备间传输大量数据库，例如磁盘、内存，而不需要通知cpu的数据传输<br><img src="http://devfqh.com/images/ComputerBase/CBase_p58.png" alt=""><br>             、<br><strong>通道方式：</strong>可减少CPU对I/O的干预，从字节的干预减少到以数据块为单位的干预，而且每次CPU干预时，并不需要做数据拷贝，仅仅需发送一条启动I/O指令，以及完成I/O结束中断操作处理；</p>
<h3 id="I-O-软件原理"><a href="#I-O-软件原理" class="headerlink" title="I/O 软件原理"></a>I/O 软件原理</h3><p><strong>I/O软件的设计应该包含四个层次：</strong><br><strong>1，I/O中断处理程序：</strong>即处理当一个进程请求I/O操作时，如果I/O设备出错，则需要将该进程挂起，处理中断操作；<br><strong>2，I/O设备驱动程序：</strong>即连接I/O硬件设备，和操作系统之间的接口驱动；<br><strong>3，与设备无关的操作系统I/O软件：</strong>对于 I/O操作而言，各种操作系统的实现各不同，因此需要暴露接口给外界使用<br><strong>4，用户层I/O软件：</strong>即最终端用户操作的软件，例如使用java、.net、php、c编写的IO程序，会调用操作系统底层IO接口</p>
<p><strong>通道I/O方式：</strong>即在I/O硬件和操作系统之间建立一条传输通道<br><img src="http://devfqh.com/images/ComputerBase/CBase_p59.png" alt=""></p>
<p><strong>缓冲技术：</strong>为了解决CPU和外围设备之间速度不匹配，效率低，可采用缓冲方式；主要实现方法是在主存开辟一个存储区作为缓冲区，专门存放临时I/O的数据；<br><strong>基本思想是：</strong>当一个进程执行读写数据时，先向系统申请一个缓冲区，然后将数据高速送到缓冲区，装满后，再传输到目标中；</p>
<p><strong>单缓冲：</strong>每当一个用户进程发出一个I/O请求时，操作系统就在主存的系统区中开设一个缓冲区<br><strong>双缓冲：</strong>即传输数据时，先填满缓冲区1，然后操作系统可将缓冲区1的数据送到用户进程去，再填满缓冲区2，依次执行；<br><strong>多缓冲：</strong>又称循环缓冲，即分别填满多个缓冲区，再传输到用户进程中；</p>
<p><strong>驱动调度技术：</strong>即如何分配并发的多个输入/输出请求，需采用一种调度策略，能够按最佳次序执行要求处理IO请求；<br>调度算法较于复杂，应用层人员无需深入了解；</p>
<p><strong>提高I/O速度的方法：</strong><br><strong>1，提前读：</strong>用户经常采用顺序方式访问文件的各个盘块上数据，当读取当前盘块数据时，即可知道下次要读出的盘块地址；<br><strong>2，延迟写：</strong>即采用缓冲的方式，先一次性写入到缓冲中，最后再传输到目标文件中；</p>
<p><strong>windows2000/xp的IO系统组成：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p60.png" alt=""></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件简介"><a href="#文件简介" class="headerlink" title="文件简介"></a>文件简介</h3><p><strong>文件系统的最基本功能：</strong></p>
<pre><code>1，文件的存取
2，目录的建立和维护
3，存储空间的分配和管理
4，提供合适的文件存储方法
5，实现从逻辑文件到物理文件的转换
</code></pre><p><strong>文件：</strong>是计算机组织数据的基本单元，组成文件的信息各式各样，例如各种源程序、数据、编译文件、多媒体文件等；<br><strong>文件类型：</strong>用于区分文件的类型，通常通过后缀名来区分；<br><strong>文件属性：</strong><br>    基本属性：文件名、文件所有者、文件授权者、文件长度等<br>    类型属性：普通文件、目录文件、系统文件、隐藏文件、设备玩家等<br>    管理属性：如创建时间、最后存取时间、最后修改时间等<br>    控制属性：逻辑记录长、文件当前长、文件最大长、以及允许的存取方式标志、关键字位置、关键字长度等</p>
<p><strong>文件存储方法：</strong><br>    1，顺序存取：按记录顺序进行读/写操作<br>    2，直接存取：即按任意次序直接读写文件，需得到文件的物理块号；<br>    3，索引存取：基于索引文件的索引存取方法，快速</p>
<p><strong>文件的使用：</strong>最基本的步骤如下<br>    1，建立文件<br>    2，打开文件<br>    3，进行读写操作<br>    4，关闭文件</p>
<h3 id="目录简介"><a href="#目录简介" class="headerlink" title="目录简介"></a>目录简介</h3><p><strong>简介：</strong>目录是用于管理文件的分组、建立、维护、检索的结构；<br>unix/linux采用了一种特殊的目录，为了减少检索文件访问的物理块数，将文件目录中项的文件和其它管理信息分开，后者单独组成定长的一个数据结构，称为索引节点（i-node），存储一些文件/目录信息；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p61.png" alt=""></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p62.png" alt="">            </p>
<p><strong>一级目录结构：</strong>即最基本的文件结构，在操作系统中构造一张线性表，与每个文件有关的属性占用一个目录项，就成了一级目录结构；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p63.png" alt="">  </p>
<p><strong>二级目录结构：</strong>即一级目录为主文件目录，用于管理所有用户文件目录，而二级目录为用户真实的文件目录；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p64.png" alt="">  </p>
<p><strong>树形目录结构：</strong>现代操作系统的目录结构，最为常用，例unix/linux系统的目录如下；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p65.png" alt=""></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p66.png" alt="">                          </p>
<p><strong>文件的存储：</strong>通常有页、块、段、组等组织方式，管理可通过顺序、直接、队列、栈、索引等方式；</p>
<p><strong>常见的文件系统：</strong><br>    FAT32：单个文件不可大于4GB<br>    NTFS：碎片少、性能佳、安全性强、可压缩 NTFS的文件、设定权限、支持大于4GB的单个文件等</p>
<p>具体细节无需理解，由操作系统实现；</p>
<h2 id="操作系统安全"><a href="#操作系统安全" class="headerlink" title="操作系统安全"></a>操作系统安全</h2><p>计算机安全是一项复杂的学科，其包括了操作系统安全、网络安全、数据库安全等多项分支；</p>
<p><strong>对于计算机系统和网络通信有四项基本安全要求：</strong><br><strong>1，机密性（confidentiality）：</strong>要求计算机系统中的信息只能由被授权者进行访问，例如打印、显示、查看等其它形式<br><strong>2，完整性（integrity）：</strong>要求计算机系统中的信息只能被用户所修改，删除、创建等<br><strong>3，可用性（availability）：</strong>防止非法独占资源，每当合法用户需要时，总能访问到合适的计算机系统资源，为其提供所需的服务<br><strong>4，可靠性（authenticity）：</strong>要求计算机系统能证实用户的省份，防止非法用户侵入系统</p>
<p><strong>常见的普通威胁：</strong><br><strong>1，切断：</strong>系统的资源被破坏，或变得不可用，是对可用性的威胁，例如破坏硬盘、切断通信线路等<br><strong>2，截取：</strong>未经授权的用户、程序获得了对计算机系统某资源的访问，这是机密性的威胁，例如在网络中窃取数据<br><strong>3，篡改：</strong>未经授权的用户、程序获得了对计算机系统某资源的访问，而且还可进行篡改，对完整性的破坏，例如修改文件数据等<br><strong>4，伪造：</strong>未经授权的用户将伪造的对象插入到系统中，这是对合法性的破坏</p>
<p><strong>操作系统保护层次：</strong><br><strong>无保护：</strong>当敏感的过程是在独立的时间内运行的<br><strong>隔离：</strong>意味着每个进程并不感觉到其它进程的存在，当然也没有任何进程通信及共享资源<br><strong>共享或不共享：</strong>即定义资源是否可被任意进程访问<br><strong>通过访问控制的共享：</strong>操作系统检查特定用户对特定对象的访问许可<br><strong>通过权能的共享：</strong>扩展了访问控制的概念，允许动态生成对共享对象的访问权利<br><strong>限制对象的使用：</strong>不仅限制了对对象的访问，而且还限制存取后对对象的使用方式；</p>
<p><strong>内存储器的保护：</strong>需分离各个进程的存储空间，否则一个进程能够不经意的写入到另外一个进程的存储空间，这后一个进程就可能会不正确运行；</p>
<p><strong>面向用户的访问控制：</strong>最普遍的方法是用户登录，即通过用户标识名和口令来完成；<br><strong>面向数据的访问控制：</strong>即针对数据权限表，再进行过滤；</p>
<p><strong>入侵技术：</strong>通常分为两种，病毒和黑客，其获取口令的方式通常有<br>1，尝试所有标准的口令试猜，例如root、admin、test<br>2，尝试一些简单常用的口令<br>3，收集用户信息，如姓名、生日、业余爱好、电话号码、身份证、车牌号等<br>4，通过特洛伊木马绕过访问限制<br>5，窃听远程用户和主机系统之间的线路</p>
<p>对于前面集中猜试的方式，很难实现入侵，可通过限制登录失败次数，并冻结用户来解决；主要是防止木马和窃听远程用户和主机系统之间；</p>
<p><strong>口令保护：</strong>系统的第一道防线，即提供用户标识和口令即可登录，并通过权限来验证<br><strong>入侵检测：</strong>系统的第二道防线，即通过某些算法来检测是否为入侵者，因为入侵者和授权用户的典型行为不同，可能会查看隐私文件、收集数据等操作；</p>
<p><strong>病毒：</strong>通常是携带在操作系统中的恶意代码或程序块，难以发现；<br><strong>主要阶段：</strong>潜伏   —-&gt;  传播    ——&gt;   触发  —–&gt;   执行<br><strong>病毒类型：</strong><br><img src="http://devfqh.com/images/ComputerBase/CBase_p67.png" alt=""> </p>
<p><strong>反病毒方法：</strong>最理想的方式就是预防，但也很难解决所有的问题，另外一种比较好的方式为<br><strong>检测：</strong>一旦发生感染，就要确定病毒的位置<br><strong>识别：</strong>当检测成功后，就要识别病毒的类型<br><strong>清楚：</strong>一旦识别出病毒，根据病毒消除，并回复程序原来的状态</p>
<p><strong>安全操作系统的设计：</strong><br>1，基本功能如用户认证、存储器保护、共享资源同步、进程通信等<br>2，隔离，各个进程之间应该是隔离的，互不影响<br>3，内核，完成最底层支撑功能，如进程间通信，信号传递等等<br>4，分层设计，各层之间应该是分离的，例如按硬件、核、操作系统、用户等<br>5，环结构，是分层设计的改进及具体化，较为复杂</p>
<p><strong>加密机制：</strong>即将信息编码成像密文一样难解形式的技术；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p68.png" alt="">         </p>
<p><strong>基本的加解密算法：</strong>虽然加密算法很多，但最基本的有两种，其它算法都是由此演变而来的；<br><strong>1，易位法：</strong>通过重新排列明文中各个字符的位置来形成密文，易位时，先设计一个密钥，对它对明文进行易位，并形成密文；解密时工具密钥再排序<br><strong>2，置换法：</strong>将明文中的字母按英文字母顺序，往后移动位生成新的替代字母，例如house就变成了hrxvh</p>
<p><strong>对称加密：</strong>即加密和解密使用的是同一个密钥（key），例如常见的DES，但其缺点在于需要传递密钥给客户端，此过程可能会被拦截，那么加密和解密就同样的密钥，则出错；</p>
<p><strong>非对称加密：</strong>即提供了两个密钥（key），一个公钥（public key），一个私有钥（private key），私钥不能外泄，而公钥可以外泄；例如向银行请求一个公钥，通过公钥加密后，那么只有私钥的持有人，银行才能对消息进行解密；与对称加密不同的时，银行不需要将私要通过网络发出去，因此安全性大大提高，目前非对称加密算法是RAS算法；</p>
<p>其它方式还有审计、签名生成等方式；</p>
<p><strong>实例研究 - windows 2000/xp的安全机制：</strong><br>安全登录机制：要求用户访问系统之前，输入唯一的登录标识符和密码来标识自己；<br>谨慎访问控制：允许资源的所有者决定哪些用户可以访问资源和他们可以如何处理资源，通常以角色、用户组、权限的方式控制；<br>安全审核：提供检测和记录与安全性有关的任何创建、访问、删除系统资源<br>内存保护：防止非法进程访问其它进程的内存<br>活动目录：<br>Kerberos5身份验证协议：<br>基于Secure Sockets Layer 3.0 的安全通道：</p>
<p><strong>windows 2000/xp - 安全性系统组件：</strong><br>1，安全引用监视器（SRM）：负责对对象的安全访问检查、处理权限、及产生任何结果安全审核消息<br>2，本地安全权限（LSA）服务器：运行映象LSASS.exe的用户态进程，负责本地系统安全性规则，用户身份验证等<br>3，LSA策略数据库：包含了系统安全性规则设置的数据库<br>4，SAM数据库：包含定义用户、组、密码的数据库<br>5，默认身份认证包：<br>6，网络登录服务：是一个以响应网络登录请求的服务，与本地系统度类似</p>
<p><strong>访问控制策略：</strong>当用户登录到windows2000/xp后，系统会以名字/口令的方式验证，如果登录成功，则为改用户创建一个进程，同时又有一个access token与这个进程对象关联；</p>
<p><strong>access token的主要用途：</strong><br>    1，负责协调所有必须的安全信息，当一个用户相关联的任何进程试图访问时，安全子系统使用与该进程相关联的访问令牌来确定用户的访问权<br>    2，允许每个进程以一种受限的方式修改自己的安全特性，但不会影响代表用户允许的其它进程</p>
<p><strong>访问令牌的通用结构：</strong><br>    1，安全ID：在网络中唯一确定一个用户，通常是登录名<br>    2，组SID：关于该用户属于那些组的列表<br>    3，特权：改用户可调用的一组对安全性敏感的系统服务<br>    4，默认的所有者：如果该进创建了一个对象，这个域确定了谁是新对象的所有者，通常新进程的所有者和派生它的进程的所有者相同，可指定相同的组SID<br>    5，默认ACL：这是适用于保护用户创建的所有对象的初始表，用户可为他拥有的或所在组所拥有的任何对象修改ACL</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -计算机基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1,计算机组成]]></title>
      <url>/2015/03/22/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
      <content type="html"><![CDATA[<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机发展历史"><a href="#计算机发展历史" class="headerlink" title="计算机发展历史"></a>计算机发展历史</h2><p><strong>计算机科学：</strong>简单一句话，即研究计算机与人类社会生活所相关的一门学科，其分支有数据库、数据挖掘、人工智能、机器学习、网络安全、分布式系统、服务系统、图形学、系统、大数据/云计算等…</p>
<p><strong>计算思维：本质就是思考社会自然现象  —&gt; 抽象到  —-&gt; 计算机的过程；</strong></p>
<p><strong>绪论：</strong>从1946-2-15第一台计算机ENIAC诞生以来，计算机经过了60多年的发展，一下以硬件和软件两方面介绍计算机发展历史；<br><strong>计算机硬件发展史：</strong><br><strong><em>第一代：</em></strong>1946-1959，电子管（真空管）时代，主要用于商用，限制于专业人士进入机房，大型机构才负担的起；<br><strong><em>第二代：</em></strong>1959-1965，晶体管时代，减小计算机体积、成本，中小型企业也可负担得起<br><strong><em>第三代：</em></strong>1965-1975，中、小规模集成电路，即将部件集成到一块芯片上，从此诞生了程序、软件行业<br><strong><em>第四代：</em></strong>1975-1985，超大规模集成电路时代，出现了微型计算机，电路板，且开始出现计算机网络<br><strong><em>第五代：</em></strong>1985-至今，超级规模集成电路时代，即现代计算机，出现了个人电脑、存储设备、多媒体、虚拟现实等现；</p>
<p><strong>计算机软件发展史：</strong><br><strong>机器语言阶段（50年代）：</strong>最早期，只能通过0和1，打孔时编程，空白时期，根本没有计算机软件，完全由程序员手工移动数据、排序，没有程序流的概念<br><strong>汇编语言阶段（50年代）：</strong>通过一些符号来代替0和1<br><strong>程序批处理阶段（60年代）：</strong>编译器的出现，开始出现一些高级语言， 控制流的概念产生，出现了数据类型、子程序、函数等概念，使得复杂的程序模块化、相对独立<br><strong>多用户阶段（70年代）：</strong>出现了unix系统，完成多用户，由此出现了c风格的编程语言，延续至今<br><strong>分布式管理阶段（80年代）：</strong>基于unix操作系统，人们开始在此环境上研究分布式操作系统、分布式应用软件<br><strong>软件重用阶段（90年代）：</strong>出现了面向对象技术，并得到广泛应用，大量的软件可视化界面，视窗，操作系统出现，并随着Internet网络技术的成熟，基于Web的分布式应用软件成为主流，并出现了软件工程的概念<br><strong>Web服务阶段（至今）：</strong>Internet的分布式软件，仍然是主流，如j2ee，web service等</p>
<p><strong>计算机的发展趋势：</strong>云计算、虚拟化：通过虚拟化技术，将一台物理计算机虚拟为多台逻辑计算机。并同时允许多个不同的操作系统，且应用程序之间可在互相独立的空间允许而互不影响，从而显著提高计算机的工作效率。</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p1.png" alt=""><br><img src="http://devfqh.com/images/ComputerBase/CBase_p2.png" alt=""></p>
<h2 id="冯诺依曼模型："><a href="#冯诺依曼模型：" class="headerlink" title="冯诺依曼模型："></a>冯诺依曼模型：</h2><p><strong>冯诺依曼模型：</strong>约1945年提出计算机设计思想，奠定了现代计算机体系的基础结构，其基本思想：<br>1，运算和存储分离<br>2，通过二进制来表示数据和指令（包含了操作码和地址吗）<br>3，采用存储程序的方式，是冯诺依曼的核心， 在程序执行前，将指令提前在存储器中，运算过程，按地址连续寻访执行<br>4，由五大部件构成：存储器、运算器、控制器、输入设备、输出设备<br><strong><em>存储器：</em></strong>存储数据、及程序执行的指令<br><strong><em>运算器（算术逻辑单元）：</em></strong>负责执行指令，即进行运算（数学、逻辑等）<br><strong><em>控制器（控制单元）：</em></strong>负责解释指令，即对存储器、输入/输出设备、运算器进行管理<br><strong><em>输入设备/输出设备：</em></strong>即接收计算机外部输入数据，并输出运算结果的设备</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p3.png" alt=""></p>
<p><strong>现代计算机结构：</strong>本质上仍然属于冯诺依曼计算机模型；将运算器和控制器集成到了一块芯片上，且存储信息量的加大，逐步变成了以存储器为中心；</p>
<p><strong>变成三部分：</strong>CPU、主存储器、输入/输出设备；</p>
<h2 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h2><p><strong>系统软件：</strong>即保证计算机系统高效、正确运行的基础软件，通常作为系统资源系统，例如操作系统、编译器、语言处理程序，各种服务程序；<br><strong>应用软件：</strong>通常是为用户解决某个应用领域中的各类问题而产生的程序，例如聊天qq、购物淘宝、娱乐游戏等；</p>
<h2 id="计算机系统的组织结构"><a href="#计算机系统的组织结构" class="headerlink" title="计算机系统的组织结构"></a>计算机系统的组织结构</h2><p><strong>硬件和软件的关系：</strong>两者紧密相关，硬件是物质基础，没有硬件，再好的软件也无法运行；而软件是灵魂，没有软件，再好的硬件也只是空壳而已；<br><em>计算机系统的层次划分（无统一方式，仅作参考）：</em></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p4.png" alt=""><br><img src="http://devfqh.com/images/ComputerBase/CBase_p5.png" alt=""></p>
<h2 id="计算机的特点和性能指标"><a href="#计算机的特点和性能指标" class="headerlink" title="计算机的特点和性能指标"></a>计算机的特点和性能指标</h2><p><strong>性能指标：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1，连续工作</div><div class="line">2，速度快</div><div class="line">3，精度高</div><div class="line">4，强大的存储能力和逻辑判断能力</div><div class="line">5，通用性强，适用于各个领域</div></pre></td></tr></table></figure></p>
<p><strong>计算机分类：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，按处理信息量</div><div class="line">2，按计算机字长，如8位、16位、32位、64位机</div><div class="line">3，按应用范围</div><div class="line">4，按计算机规模，如单片机、微型机、小型机、大型机、巨型机、超级巨型机等</div></pre></td></tr></table></figure></p>
<p><strong>计算机应用：</strong>科学计算、数据处理、现代控制、网络、人工智能</p>
<h1 id="信息的表示"><a href="#信息的表示" class="headerlink" title="信息的表示"></a>信息的表示</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>计算机信息的表示：</strong><br> 1，数值型0和1<br> 2，编码型，即使用一些符号来表示数据，再将符号转成0和1，常见如ASCII、gbk、utf-8</p>
<p><strong>数据类型：</strong>常见的五种数据类型：数字、文字、音频、图像、视频；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p6.png" alt=""></p>
<p><strong>存储单位：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bit（位）：计算机的最小单位，值为0或1，在嵌入式开发中，通常表示开或关；</div><div class="line">byte（字节）：1byte = 8bit</div><div class="line">KB--&gt; MB-&gt; GB -&gt; TB之间的单位则为1024</div></pre></td></tr></table></figure></p>
<h2 id="数据类型的存储"><a href="#数据类型的存储" class="headerlink" title="数据类型的存储"></a>数据类型的存储</h2><h3 id="存储数值"><a href="#存储数值" class="headerlink" title="存储数值"></a>存储数值</h3><p><strong>说明：</strong>对于数值类型在计算机中的存储，主要有问题有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1，如何处理符号，即正、负数</div><div class="line">2，如何处理小数点</div><div class="line">3，当一个十进制数 -&gt; 二进制时存储到计算机中时，如果不足一个bit，即8位，则在左边补0；</div><div class="line">  例如十进制7变成二进制     --&gt;    111</div><div class="line">  不足一个bit，8位，需在左边补0  --&gt;  00000111</div></pre></td></tr></table></figure></p>
<p><strong>（整数）数值型在计算机中的表示：</strong>通常有原码、反码、补码三种形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原码：使用数值的最高位来代表符号位，0代表正数；1代表负数；</div><div class="line">反码：正数的反码与原码相同；负数的反码等于除了最高位符号外，其它位取反；</div><div class="line">补码：正数的补码与原码相同；负数的补码等于其反码+1；</div></pre></td></tr></table></figure></p>
<p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1100110011 原</div><div class="line">1011001100 反，除最高位符号位外，其它按位取反</div><div class="line">1011001101 补，反码+1</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p7.png" alt=""></p>
<p><strong>浮点数在计算机中的存储处理（即实数，带小数点的）：</strong>整数和小数部分是分开存储的，且小数点事隐藏的，通常小数部分分成三部分，符号、指数、尾数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">符号位：即表示正负数，0为正，1为负</div><div class="line">指数：以2为底，小数点需要移动的位数</div><div class="line">尾数： 小数点右边的二进制数</div></pre></td></tr></table></figure></p>
<p><strong>IEEE标准：</strong>定于了几种存储浮点数的标准，以下为单精度32位，和双精度64位的存储</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p8.png" alt=""></p>
<p><strong>例如：</strong>12.5在计算机中的存储（我也搞不懂，随便看下得了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1. 将整数部分12转为二进制1100，0.5转为二进制.1，并连起来，从第一位开始取24位，后面补0</div><div class="line">      1100.10000000000000000000</div><div class="line"></div><div class="line">2. 把小数点移到第一个1的后面，需要左移3位, 加上偏移量127，127+3=130，二进制是10000010，这是阶码。    </div><div class="line"></div><div class="line">3. -12.5是负数，所以符号位是1。把符号位，阶码和尾数连起来。注意，尾数的第一位总是1，所以规定不存这一位的1，只取后23位：</div><div class="line">      1 10000010 10010000000000000000000</div><div class="line">   把这32位按8位一节整理一下，得：</div><div class="line">      11000001 01001000 00000000 00000000</div><div class="line">   就是十六进制的 C1480000.</div></pre></td></tr></table></figure></p>
<h3 id="存储文本"><a href="#存储文本" class="headerlink" title="存储文本"></a>存储文本</h3><p><strong>简介：</strong>通常采用编码的方式， 例如ASCII、unicode存储各种文字，再将其转换成对应的二进制即可；</p>
<h3 id="存储音频"><a href="#存储音频" class="headerlink" title="存储音频"></a>存储音频</h3><p><strong>简介：</strong>由于音频和数字文本等信息不同，其是随着时间而变化的实体，计算机内部存储的方式是存储一个音频信号的密度，例如一段时间（一秒钟、一小时）来自麦克风的信号；</p>
<p><strong>音频编码：</strong>主流格式为mp3，采用每秒40000个样本，以及每样本16位来存储,在计算机内存中存储音频，需要连续的数量的内存单元，即结合音频编码去完成；（编码通常有操作系统或软件实现）</p>
<h3 id="存储图像"><a href="#存储图像" class="headerlink" title="存储图像"></a>存储图像</h3><p><strong>光栅图（即位图）：</strong>有真彩色和索引色两种，真彩色可支持超过1600万中颜色组合；而索引色仅支持少量颜色；记录色彩深度，通常是R、G、 B三原色，用0 - 255的数字来表示，24位来存储一个像素颜色值；<br>例如一部500W像素相机拍摄一张3 * 5英寸的照片，分别用以下两种方式存储所需要的位数<br><img src="http://devfqh.com/images/ComputerBase/CBase_p9.png" alt=""></p>
<p><strong>JPEG：</strong>通常使用真彩色，但会通过压缩来减少存储空间</p>
<p><strong>GIF：</strong>通常使用索引色；</p>
<p><strong>矢量图：</strong>光栅图的缺点，文件尺寸大且重新调整大小，会失真；而矢量图并不存储每个像素的位模式，而是存储几何图形的特征，例如点、线、面，矩形、圆形等，其只能通过软件生成，特点是自由、无限制重新组合，并分辨率无关，放大后图像不会失真；</p>
<h3 id="存储视频"><a href="#存储视频" class="headerlink" title="存储视频"></a>存储视频</h3><p><strong>简介：</strong>通过帧的方式来存储，并存储图像； 即视频是随着时间播放不同图像的提现；主要存储两种信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，帧,即每一帧该播放对应的图像地址信息</div><div class="line">2，图像</div></pre></td></tr></table></figure></p>
<h2 id="进制的换算"><a href="#进制的换算" class="headerlink" title="进制的换算"></a>进制的换算</h2><h3 id="进制说明"><a href="#进制说明" class="headerlink" title="进制说明"></a>进制说明</h3><p><strong>二进制（逢二进一）：</strong>即改数字往前移动一位，进一，当前变成0;<br>    1001 +1<br>    1010<br><strong>八进制（逢八进一）：</strong><br>    237 + 1 = 238，逢八进一，因此8变成0，进一后为240；<br>    240<br><strong>十进制（逢十进一）：</strong><br>    239+ 1 =240<br>    240<br><strong>十六进制（逢十六进一）：</strong>10到15，以字母ABCDEF代替<br>    12478ABCDE + 1 = 123478ABCDF,<br>    逢十六进一，F为16，进一结果为123478ABCE0<br><strong>转换说明：</strong>先转成十进制，再转成其它进制，由此可完成任意进制的转换</p>
<h3 id="其它进制转十进制"><a href="#其它进制转十进制" class="headerlink" title="其它进制转十进制"></a>其它进制转十进制</h3><p><strong> 二进制转十进制： </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1，将二进制数从右往左数，例如11010，从右往左数则为01011，</div><div class="line">2， 用该数 * 2的n次方（n为位置），然后把他们全部加起来即可；</div><div class="line">3，最终结果 = 0 * 2º  1 * 2¹   +  0 * 2²   + 1 * 2³  + 1 * 24 = 26;    （0可忽略，因为没意义）</div><div class="line">    0 第0位</div><div class="line">    1 第1位</div><div class="line">    0 第2位</div><div class="line">    1 第3位</div><div class="line">    1 第4位</div></pre></td></tr></table></figure></p>
<p><strong>八进制转十进制：</strong>同上，只是将2的n次方，换成了8的n次方，例如八进制1234转十进制；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1，从后往前数，变成4321</div><div class="line">2，用该数 * 8的第n次方（n为位置），然后把他们全部加起来即可；   </div><div class="line">3，最终结果 = 4 * 8º + 3 * 8¹  + 2 * 8² + 1 * 8³  = 2257；</div><div class="line">    4 第0位</div><div class="line">    3 第1位</div><div class="line">    2 第2位</div><div class="line">    1 第3位</div></pre></td></tr></table></figure></p>
<p><strong> 十六进制转十进制： </strong>同上，只是换成了16的n次方，再相加，例如十六进制A5B6转成十进制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1，从后往前数为6B5A</div><div class="line">2，该数 * 16的第n次方，然后把他们全部加起来即可；   </div><div class="line">3，最终结果 = 6 * 16º + 11 * 16¹   + 5 * 16² + 10 * 16³ = 42422</div><div class="line">    6 第0位</div><div class="line">    B 第1位</div><div class="line">    5 第2位</div><div class="line">    A 第3位</div></pre></td></tr></table></figure></p>
<h3 id="十进制转其它进制"><a href="#十进制转其它进制" class="headerlink" title="十进制转其它进制"></a>十进制转其它进制</h3><p><strong>十进制转二进制：</strong>用十进制数不断  / 2，每次取余，最后从下往上排列即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">123 / 2=61 余1</div><div class="line"> 61/2=30 余1</div><div class="line"> 30/2=15 余0 </div><div class="line"> 15/2=7  余1</div><div class="line">  7/2=3  余1</div><div class="line">  3/2=1  余1</div><div class="line">   1</div></pre></td></tr></table></figure></p>
<p>余数从下往上排列就是111011，注意需要加上最后一步3 / 2 = 1中的1放到最前面得到1111011</p>
<p><strong>十进制转八进制：</strong>同上，用十进制不断 / 8， 取余，从下往上排列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">123 / 8 = 15;      余 3</div><div class="line">15 / 8 = 1;        余7</div></pre></td></tr></table></figure></p>
<p>最后把15 / 8 = 1; 中的1算上  ，从下往上排列就是173</p>
<p><strong>十进制转十六进制：</strong>同上，用十进制数不断 / 16  取余<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">12345  / 16 = 771  余9</div><div class="line">  771 / 16 = 48    余3</div><div class="line">  48 / 16 = 3      余0</div></pre></td></tr></table></figure></p>
<p>把最后48 / 16 = 3中的3算上，加到最前面，则从下往上排列为3039</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>转换规则：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，其它进制转十进制：从右往左数的每个数乘以2/8/16的n次方，并相加即可；</div><div class="line">2，十进制转其它进制：将十进制数不断除以2/8/16，并得到余数，然后将余数从下往上记即可，且需加上最后的商；</div></pre></td></tr></table></figure></p>
<p><strong>小数点的处理（了解即可）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，其它进制小数转十进制：同样处理，小数点部分指数为负数，1101.01 = 1*20 + 0*21+1*22 + 1*23 + 0*2-1 + 1*2-2 = 1 + 0 + 4 + 8 + 0 + 0.25 = 13.25</div><div class="line">2，十进制小数转其它进制：整数和小数分别转换.</div></pre></td></tr></table></figure></p>
<h4 id="整数除以2-商继续除以2-8-16-得到0为止-将余数逆序排列"><a href="#整数除以2-商继续除以2-8-16-得到0为止-将余数逆序排列" class="headerlink" title="整数除以2,商继续除以2/8/16,得到0为止,将余数逆序排列."></a>整数除以2,商继续除以2/8/16,得到0为止,将余数逆序排列.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">22 / 2 11 余0</div><div class="line">11/2 5 余 1</div><div class="line">5 /2 2 余 1</div><div class="line">2 /2 1 余 0</div><div class="line">1 /2 0 余 1</div><div class="line">所以22的二进制是10110</div></pre></td></tr></table></figure>
<h4 id="小数乘以2-取整-小数部分继续乘以2-取整-得到小数部分0为止-将整数顺序排列"><a href="#小数乘以2-取整-小数部分继续乘以2-取整-得到小数部分0为止-将整数顺序排列" class="headerlink" title="小数乘以2,取整,小数部分继续乘以2,取整,得到小数部分0为止,将整数顺序排列."></a>小数乘以2,取整,小数部分继续乘以2,取整,得到小数部分0为止,将整数顺序排列.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0.8125 取出整数部分 --&gt; 0.</div><div class="line">0.8125 x 2=1.625，取整 --&gt; 1,小数部分是0.625</div><div class="line">0.625 x 2 = 1.25， 取整   --&gt; 1,小数部分是0.25</div><div class="line">0.25 x 2=0.5，取整   --&gt;  0,小数部分是0.5</div><div class="line">0.5 x 2=1.0，取整 ---&gt; 1,小数部分是0,结束</div><div class="line">所以0.8125的二进制是0.1101</div></pre></td></tr></table></figure>
<h1 id="运算方法"><a href="#运算方法" class="headerlink" title="运算方法"></a>运算方法</h1><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p><strong>说明：</strong>在计算机中，通常0代表false，1代表true;</p>
<p><strong>逻辑运算符主要有：</strong>&amp;（位与）、|（位或）、~（非）、^（异或）</p>
<p><strong>&amp; ：</strong>位与（AND），两个都是1，返回1，其它返回0；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p10.png" alt=""></p>
<p><strong>|：</strong>位或（OR），有一个为1则返回1，2个都为0返回0<br><img src="http://devfqh.com/images/ComputerBase/CBase_p11.png" alt=""></p>
<p><strong>~：</strong>取反，0变成1,1变成0；单目运算符<br><img src="http://devfqh.com/images/ComputerBase/CBase_p12.png" alt=""></p>
<p><strong>^：</strong>异或，只有一个为1则为1，其它条件为0；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p13.png" alt=""></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><p><strong>位移运算：</strong>将数值的二进制形式，左移或右移n位. 不足补0.<br>    &lt;&lt;：左移变大       高位舍弃，低位补0;</p>
<pre><code>&gt;&gt;：右移变小       低位舍弃，高位补0；
</code></pre><p><img src="http://devfqh.com/images/ComputerBase/CBase_p14.png" alt=""></p>
<p><strong>快捷算法：</strong><br>         3  &lt;&lt;  2  =   3 * 2②<br>         6  &gt;&gt;  2  =   6 / 2②<br><img src="http://devfqh.com/images/ComputerBase/CBase_p15.png" alt=""></p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p><strong>简介：</strong>底层运算较为复杂，对于应用层人员，无需深入了解，通常是通过二进制来完成运算，可通过原码、反码、补码进行+、-、*、/四则运算；</p>
<h1 id="存储器系统"><a href="#存储器系统" class="headerlink" title="存储器系统"></a>存储器系统</h1><p><strong>简介：</strong>主要功能是存储程序和数据，是冯诺依曼计算机的五大部件之一，其主要分类如下；</p>
<p><strong>按与CPU的连接功能分类:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，主存储器：CPU能够直接访问的存储器，用于存放当前运行的程序和数据，由于其设在主机内部，又称为主存或内存；</div><div class="line">2，辅助存储器（外部）：解决主存空间不足的问题，存放不参与运行的程序和数据，CPU不能直接访问，例如硬盘</div><div class="line">3，高速缓存存储器：介于主存和CPU之间，主要用于存放CPU即将要运行或刚刚使用过的程序和数据</div></pre></td></tr></table></figure></p>
<p><strong>按存取方式分类:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，随机存储器（RAM）：可按地址随机的读取或写入，在断电后可能会数据丢失，例如常见的硬盘、u盘</div><div class="line">2，只读存储器（ROM）：只读存储器，可编程式，由制造商写入，优点是数据不会丢失；</div><div class="line">3，顺序存储器（SAM）：存储信息的排列、寻找、读写操作是按顺序进行的</div><div class="line">4，直接存储器（DAM）：介于RAM和SAM之间的存储器</div></pre></td></tr></table></figure></p>
<p><strong>按存储介质分类:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，磁芯存储器：早期，利用两种不同的磁芯状态来存放二进制代码0和1</div><div class="line">2，半导体存储器（常用于主存）：采用半导体，分为双极性和MOS型</div><div class="line">3，磁表面存储器：利用涂在表面上的一层磁性材料存放二进制代码，例如磁盘、磁带等</div><div class="line">4，光存储器：利用光学原理支撑的存储器，通过能量高度集中的激光束照在基体表面引起物理/化学的变化，记忆二进制信息</div></pre></td></tr></table></figure></p>
<p><strong>主存储器的组成：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">存储阵列：核心，用于存储二进制信息的主体，有大量的存储单元组成，又称存储体</div><div class="line">地址寄存器：存放所要访问的存储单元的地址，</div><div class="line">地址总线：要访问一个存储单元，必须通过地址总线将其地址放到寄存器中</div><div class="line">数据寄存器：获取该存储单元的数据</div><div class="line">数据总线：通过数据总线输出给目标设备</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p16.png" alt=""></p>
<p><strong>存储器的性能指标：</strong>容量、速度、价格、数据传输率</p>
<p><strong>存储器的层次结构：</strong>由下往上，越顶层速度越快、价格越昂贵；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p17.png" alt=""></p>
<h1 id="CPU与控制系统"><a href="#CPU与控制系统" class="headerlink" title="CPU与控制系统"></a>CPU与控制系统</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p><strong>cpu：</strong>现代计算机中，将控制器、运算器、寄存器集成到了一块芯片上，通常称为CPU；</p>
<p><strong>1. 算术逻辑单元（运算单元ALU）：</strong>主要对数据进行逻辑、移位、算术运算<br><strong>2. 寄存器（快速存储单元）：</strong>用于存放临时数据的高速独立存储单元，主要作用有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2.1 数据寄存器：较为少用，通常使用硬盘来存储数据</div><div class="line">2.2 指令寄存器：cpu需要从内存中取出指令，并存储到寄存器中，解释并执行；</div><div class="line">2.3 程序计数器：保存当前正在执行的指令，并存储下一条指令的内存地址；，</div><div class="line">2.4 地址寄存器、数据缓冲寄存器等</div></pre></td></tr></table></figure></p>
<p><strong>3. 控制单元：</strong>复制从存储器中取出指令、并执行程序，控制各个子系统之间的协调工作；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">3.1，控制指令的正确执行</div><div class="line">3.2，控制程序和数据的输入、输出结构</div><div class="line">3.3，异常情况和特殊请求的处理</div></pre></td></tr></table></figure></p>
<p><strong>指令执行的基本步骤：</strong>根据存放在存储器中的程序，取出指令，并执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 取指令：即cpu的控制单元将下一条要执行的指令从内存中，复制到寄存器中。 其指令地址将会被存储到程序计数器中，+1代表指向下一条指令的地址</div><div class="line">2. 分析指令（译码）：当取出指令存放到寄存器中，需要由控制单元将指令译码成系统可指向的二进制代码</div><div class="line">3. 执行指令译码完成后，控制单元会通知系统，从内存中加载数据或计算，最终将结果保存在输出寄存器中；</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p18.png" alt=""></p>
<p><strong>控制方式：</strong>计算机执行指令的过程，需要在时间上对各个微操作进行控制，主要方式有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，同步控制方式：即一条指令完成后，才能转向并继续后续的指令操作</div><div class="line">2，异步控制方式：需要硬件设备的支持，较为繁琐复杂</div><div class="line">3，联合控制方式：同步和异步相结合的控制方式</div></pre></td></tr></table></figure></p>
<p><strong>并行处理：</strong>即采用多个控制单元、多个算术逻辑单元、多个内存单元的计算机，同时处理多项任务，提高效率；<br><strong>SISD：</strong>单指令流、单数据流表示计算机只有一个控制单元、一个算术逻辑单元、一个内存单元<br><strong>SIMD：</strong>单指令流、多数据流，表示计算机只有一个控制单元、多个算术逻辑单元、一个内存单元<br><strong>MISD：</strong>多指令流、多数据流，</p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><p><strong>机器指令：</strong>在计算机中，指令是计算机硬件唯一能够直接理解并执行的命令，故又称机器指令，通过机器语言编写，由于机器语言是计算机唯一能够直接理解并执行的语言，因此其它语言的程序必须经过翻译成机器语言，才能运行；</p>
<p><strong>机器指令格式：</strong>以二进制代码表示， 分为操作码和地址码；<br>    <strong>操作码：</strong>存储指令应执行的操作<br>    <strong>地址码：</strong>可存储指令所涉及的操作数据的存放地址</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p19.png" alt=""></p>
<p><strong>寻址方式：</strong>根据存储程序的概念，计算机在运行之前必须把程序和数据存入主存中，为保证程序能够连续运行，在运行过程中，需不断的从主存中读取指令，那么就需要通过寻址来找到指令的地址并运行；</p>
<p><strong>指令的寻址方式：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，顺序方式：采用PC增量的方式形成下一条指令的地址，因为程序中的指令是顺序存放的，按一定的增量即可形成下一条指令地址</div><div class="line">2，跳跃方式：当程序发生转移时，根据指令的转移目的地址修改PC内容</div></pre></td></tr></table></figure></p>
<p><strong>操作数的寻址方式：</strong>由于操作数的存放不如指令的存放有规律，其可能存储在主存或寄存器中，而且有时存储是原始数据、有时是运算结构，较为复杂；</p>
<p><strong>1，立即寻址：</strong>按指令的地址码部分给出的部分，是操作数本身，而不是操作数的地址</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p20.png" alt="">             </p>
<p><strong>2，直接寻址：</strong>根据指令的地址码给出不愤怒，找到其操作数的地址，在根据地址找到操作数本身</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p21.png" alt="">         </p>
<p><strong>3，间接寻址：</strong>分为一级间址和多级间址，一级是指指令的形式地址A给出的是存储单元的地址，此时存储单元中的内容就是操作数的有效地址；多级是指指令的地址码部分给出的是操作数的地址</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p22.png" alt=""></p>
<p><strong>4，寄存器直接寻址：</strong> 指令地址给出的是某个寄存器的编号或地址，改寄存器的内容即为指令所需的操作数据</p>
<p><strong>其它寻址方式：</strong>寄存器间接寻址、变址寻址、相对寻址、基址寻址、基址+变址寻址、页面寻址、扩展寻址</p>
<p><strong>堆栈寻址：</strong>由堆栈支持的寻址方式，按先进后出或者后进先出的方式进行存取，在堆栈结构中，第一个存入的单元称为栈底，最后一个存入的单元称为栈顶；通常栈底是不变的，而栈顶是随着数据单元的进栈出栈而浮动变化的；计算机的堆栈分为两种；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1，寄存器堆栈：速度快，但是容量小，不易扩展</div><div class="line">2，存储器堆栈：普遍采用，速度略慢，但是容量大</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p23.png" alt="">   </p>
<p><strong>指令的类型：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1，数据传送指令：计算机中最基本、最常用的指令，实现一个部件与一个部件之间的数据传送，例如寄存器与存储单元、存储单元与CPU、存储单元与IO设备</div><div class="line"></div><div class="line">2，算术逻辑运算指令：即完成各类数据信息的处理，运算，如四则运算、逻辑运算</div><div class="line"></div><div class="line">3，移位指令：完成位运算、如左移、右移等</div><div class="line"></div><div class="line">4，堆栈操作指令：特殊的数据传送指令，分为进栈和出栈，进栈则将将数据送入栈顶，出栈指令是将栈顶数据送到指令制定的目的地址中</div><div class="line"></div><div class="line">5，字符串处理指令：处理字符串，如查找、抽取、替换、比较、匹配等</div><div class="line"></div><div class="line">6，程序控制指令：转移指令、循环指令、返回指令、子程序调用等</div><div class="line"></div><div class="line">7，I/O指令：主要用于主机和外部设备之间的数据输入输出，接收外部设备数据，并返回结果给外部设备</div><div class="line"></div><div class="line">8，其它指令：如控制指令、关机、停机、重启等...</div></pre></td></tr></table></figure></p>
<p><strong>复杂指令系统计算机（CISC）：</strong>早期使用，指令复杂庞大，格式多，寻址方式多，时间和频率相差大；</p>
<p><strong>精简指令系统计算机（RISC）：</strong>相比CISC更加简单化</p>
<h1 id="总线技术"><a href="#总线技术" class="headerlink" title="总线技术"></a>总线技术</h1><h2 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h2><p>计算机系统大多采用模块结构，一个模块就是一块功能插件、部件，例如CPU模块、存储器模块、各种I/O接口等；各模块之间传送信息的公共通道称为总线；</p>
<p>总线就是一个共享的传输媒介，当多个设备连接到总线上时，任何一个设备都可通过总线传输、接收数据；为避免总线上的信息不冲突，同时只允许一个设备向总线发送信号，以保证总线上信息每时每刻都是唯一的</p>
<p>通常一条总线由多条通信线路组成，每条通信线路能够传输一位二进制的1或0的信号；</p>
<p><strong>主要的总线：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cpu总线：一级数据线，用于连接cpu内部各寄存器和算术逻辑部件的总线。</div><div class="line">部件内总线：在计算机中，通常按功能模块制作插件，每个插件上也有总线结构来连接有关芯片</div><div class="line">系统总线：连接系统内各大部件，如cpu、存储器、i/o设备的总线，是连接整个计算机的基础，其包括了地址线、控制线、数据线、状态信号线等</div><div class="line">外总线：计算机系统与计算机系统之间通信的总线；</div></pre></td></tr></table></figure></p>
<p><strong>总线的组成：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1，数据总线：为系统部件之间提供传输数据的通道，每根线上每次传送1bit的数据，双向传输</div><div class="line">2，地址总线：传输地址信号，传输内存、数据地址、I/O端口的寻址，单向传输</div><div class="line">3，控制总线：负责在中央处理器和内存之间传输控制信号（数据、程序指令），以控制系统完成规定的操作</div></pre></td></tr></table></figure></p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p24.png" alt=""> </p>
<p><strong>按总线信息传送方向区分，可分为单向总线和双向总线两种：</strong><br><strong>单向总线：</strong>cpu通过单总线访问主存储器，cpu与各I/O设备之间，I/O设备与主存储器之前，都可以通过这组单总线交换信息，其缺点在于同一时刻只能在一对设备之间或部件之间传送数据，因此系统速度受到限制，且CPU与主存储器之间的信息非常频繁，因此在CPU与主存之间增加了一组存储器总线，CPU访问通过存储器总线实现，由此发展成了面向主存的双总线结构；<br><strong>双向总线：</strong>由于CPU与主存储器的信息传输非常频繁，因此加了一组存储总线之后，    即可直接访问存储器，提高了系统效率；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p25.png" alt=""><br><img src="http://devfqh.com/images/ComputerBase/CBase_p26.png" alt=""> </p>
<h1 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h1><p><strong>简介：</strong>I/O设备是实现计算机系统与外界之间交互的装置；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入设备：计算机接收外界数据，例如键盘、鼠标、扫描仪、磁盘、摄像机等</div><div class="line">输出设备：将计算机处理结果，转换成可识别的信息形式，例如打印机、显示器、音响等</div></pre></td></tr></table></figure></p>
<p><strong>I/O系统概述：</strong>解决计算机主机与外部设备之间的数据交换格式问题；</p>
<p><strong>I/O系统的组成：</strong>通常分为四部分，扩展总线、I/O设备、I/O接口、相关控制软件。典型结构图如下<br><img src="http://devfqh.com/images/ComputerBase/CBase_p27.png" alt=""> </p>
<p>虽然系统总线作为公共信息桐庐，但IO设备不能直接连接到系统总线上，需通过扩展总线以及I/O接口来实现I/O设备与主机之间的连接；</p>
<p><strong>主机与外部设备的连接方式：</strong><br><strong> 1，总线型连接方式：</strong>CPU通过系统总线与主存、IO接口进行相连，通过IO接口控制器对外部设备进行控制，较为常用；<br><strong> 2，通道控制连接方式：</strong>主要用于大型机，连接数较多的场合；通过一个通道控制器来完成IO总线和系统总线之间的连接<br><strong>通道控制器：</strong>专门负责IO操作的控制器，在此种模式下，CPU不再负责具体的IO控制，转交给通道控制器，实现了处理器和通道控制器和外部设备的并行工作；</p>
<p><img src="http://devfqh.com/images/ComputerBase/CBase_p28.png" alt="">               </p>
<p><strong>3，I/O处理控制连接方式：</strong>可适用于巨型机，也可适用于微型机</p>
<p><strong>I/O接口：</strong>指主机和外部设备之间的连接接口，如USB、hdmi等都是，主要功能有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1，数据传送、缓冲、隔离、锁存</div><div class="line">2，数据格式转换</div><div class="line">3，主机和外设的通信联络控制，例如传输命令、执行指令、中断控制等</div><div class="line">4，寻址：在一个计算机系统中，通常会连接多个外设，因此需要对众多的外部设备分配地址，完成映射</div></pre></td></tr></table></figure></p>
<p><strong>输入/输出操作：</strong>计算机通过指令将数据从I/O设备输出到cpu和内存，IO操作运行速度要比cpu慢的多，因此cpu需要与输入/输出设备同步，通常有三种同步方式</p>
<p><strong>1，程序控制输入/输出：</strong>最简单的方式，CPU遇到一条I/O指令时，就停止工作，去检查输入/输出设备的状态，如果设备以及做好传输准备，则开始传送数据到cpu，缺点是每次都需浪费时间去检测设备状态<br><img src="http://devfqh.com/images/ComputerBase/CBase_p29.png" alt="">                          </p>
<p><strong>2，中断控制输入/输出：</strong>首先cpu告知IO设备即将开始传输，但是cpu并不需要不断检测IO设备的状态，当IO设备准备好时，他通知中断CPU，在此过程中CPU还可处理其它的工作，不至于浪费操作；<br><img src="http://devfqh.com/images/ComputerBase/CBase_p30.png" alt=""> </p>
<p><strong>3，直接存储存储：</strong>适用于在高速IO设备间传输大量数据库，例如磁盘、内存，而不需要通知cpu的数据传输<br><img src="http://devfqh.com/images/ComputerBase/CBase_p31.png" alt="">              、</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -计算机基础 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
